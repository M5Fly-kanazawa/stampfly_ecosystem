<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StampFly Loop Shaping Design Tool</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
        }
        .container {
            display: grid;
            grid-template-columns: 600px 1fr;
            grid-template-rows: auto auto auto 1fr;
            gap: 15px;
            padding: 15px;
            max-width: 1800px;
            margin: 0 auto;
            height: 100vh;
            overflow: hidden;
        }
        h1 {
            grid-column: 1 / -1;
            grid-row: 1;
            text-align: center;
            color: #00d4ff;
            font-size: 1.5em;
            margin: 0;
        }
        .subtitle {
            grid-column: 1 / -1;
            grid-row: 2;
            text-align: center;
            color: #888;
            font-size: 0.85em;
            margin: 0;
        }
        /* Tab styles */
        .tabs {
            grid-column: 1 / -1;
            grid-row: 3;
            display: flex;
            gap: 4px;
            background: #16213e;
            padding: 6px;
            border-radius: 10px;
            justify-content: center;
        }
        .tab {
            padding: 8px 24px;
            border: none;
            background: transparent;
            color: #888;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }
        .tab:hover {
            background: #0f0f23;
            color: #ccc;
        }
        .tab.active {
            background: #00d4ff;
            color: #000;
        }
        .tab.calc { border-left: 4px solid #f59e0b; }
        .tab.roll { border-left: 4px solid #ef4444; }
        .tab.pitch { border-left: 4px solid #22c55e; }
        .tab.yaw { border-left: 4px solid #3b82f6; }
        .tab.all { border-left: 4px solid #8b5cf6; }
        .tab.active.calc { background: #f59e0b; }
        .tab.active.roll { background: #ef4444; }
        .tab.active.pitch { background: #22c55e; }
        .tab.active.yaw { background: #3b82f6; }
        .tab.active.all { background: #8b5cf6; }
        .panel {
            grid-row: 4;
            background: #16213e;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            overflow-y: auto;
            min-height: 0;
        }
        .panel h2 {
            color: #00d4ff;
            font-size: 1.1em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        .axis-indicator {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-left: 10px;
            color: #000;
            font-weight: bold;
        }
        .axis-indicator.roll { background: #ef4444; }
        .axis-indicator.pitch { background: #22c55e; }
        .axis-indicator.yaw { background: #3b82f6; }
        .param-group {
            margin-bottom: 20px;
        }
        .param-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 10px;
        }
        .param-row label {
            flex: 0 0 140px;
            font-size: 0.9em;
            color: #aaa;
        }
        .param-row input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        .param-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
        }
        .param-row input[type="number"] {
            width: 90px;
            padding: 6px 8px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #0f0f23;
            color: #fff;
            font-size: 0.9em;
            text-align: right;
        }
        .param-row .unit {
            flex: 0 0 60px;
            font-size: 0.8em;
            color: #666;
        }
        .results {
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .results h3 {
            color: #00d4ff;
            font-size: 0.95em;
            margin-bottom: 10px;
        }
        .result-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #222;
            font-size: 0.9em;
        }
        .result-row:last-child {
            border-bottom: none;
        }
        .result-value {
            color: #4ade80;
            font-weight: 600;
        }
        .result-value.warning {
            color: #fbbf24;
        }
        .result-value.danger {
            color: #f87171;
        }
        /* All tab results table */
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.85em;
        }
        .results-table th, .results-table td {
            padding: 8px 6px;
            text-align: center;
            border-bottom: 1px solid #333;
        }
        .results-table th {
            color: #888;
            font-weight: normal;
        }
        .results-table th:first-child, .results-table td:first-child {
            text-align: left;
        }
        .results-table .axis-roll { color: #ef4444; }
        .results-table .axis-pitch { color: #22c55e; }
        .results-table .axis-yaw { color: #3b82f6; }
        .plots {
            grid-row: 4;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .plot-container {
            background: #16213e;
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .plot-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #0f0f23;
            border-radius: 8px;
        }
        .plot-controls label {
            font-size: 0.9em;
            color: #aaa;
        }
        .plot-controls input[type="range"] {
            flex: 1;
            max-width: 200px;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        .plot-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
        }
        .plot-controls input[type="number"] {
            width: 70px;
            padding: 6px 8px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #1a1a2e;
            color: #fff;
            font-size: 0.9em;
            text-align: right;
        }
        .plot-controls .unit {
            font-size: 0.8em;
            color: #666;
        }
        #bode-plot, #step-plot {
            width: 100%;
        }
        .transfer-function {
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.6;
        }
        .tf-label {
            color: #888;
            margin-bottom: 5px;
        }
        .tf-equation {
            color: #4ade80;
        }
        .legend-info {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.85em;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }
        .legend-item input[type="checkbox"] {
            width: 14px;
            height: 14px;
            accent-color: #00d4ff;
            cursor: pointer;
        }
        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }
        .all-view-params {
            display: none;
        }
        .all-view-params.visible {
            display: block;
        }
        .calc-view-params {
            display: none;
        }
        .calc-view-params.visible {
            display: block;
        }
        .single-view-params {
            display: block;
        }
        .single-view-params.hidden {
            display: none;
        }
        .calc-input-group {
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .calc-input-group h3 {
            color: #00d4ff;
            font-size: 0.95em;
            margin-bottom: 12px;
        }
        .calc-result-group {
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .calc-result-group h3 {
            color: #f59e0b;
            font-size: 0.95em;
            margin-bottom: 12px;
        }
        .calc-result-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #222;
            font-size: 0.9em;
        }
        .calc-result-row:last-child {
            border-bottom: none;
        }
        .calc-axis-label {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.75em;
            font-weight: bold;
            margin-right: 8px;
            color: #000;
        }
        .calc-axis-label.roll { background: #ef4444; }
        .calc-axis-label.pitch { background: #22c55e; }
        .calc-axis-label.yaw { background: #3b82f6; }
        .apply-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: #000;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 10px;
        }
        .apply-btn:hover {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            transform: translateY(-1px);
        }
        .apply-btn:active {
            transform: translateY(0);
        }
        .calc-formula {
            background: #16213e;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: #4ade80;
        }
        .propeller-layout {
            display: grid;
            gap: 8px;
        }
        .prop-input-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
        }
        .prop-input-row label {
            color: #888;
            width: 15px;
        }
        .prop-input-row input {
            width: 60px;
            padding: 4px 6px;
            font-size: 0.85em;
        }
        .prop-input-row select {
            padding: 4px;
            font-size: 0.8em;
            background: #1e1e3f;
            color: #fff;
            border: 1px solid #333;
            border-radius: 4px;
        }
        .prop-label {
            width: 70px;
            font-weight: bold;
            font-size: 0.85em;
        }
        .prop-label.m1 { color: #ef4444; }
        .prop-label.m2 { color: #22c55e; }
        .prop-label.m3 { color: #3b82f6; }
        .prop-label.m4 { color: #f59e0b; }
        .matrix-display {
            background: #0a0a1a;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            overflow-x: auto;
        }
        .matrix-display h4 {
            color: #00d4ff;
            font-size: 0.85em;
            margin-bottom: 10px;
        }
        .matrix-display .katex {
            font-size: 0.9em;
        }
        .math-panel {
            background: #16213e;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            overflow-y: auto;
        }
        .math-panel h2 {
            color: #00d4ff;
            font-size: 1.1em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        .math-section {
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        .math-section h3 {
            color: #f59e0b;
            font-size: 0.9em;
            margin-bottom: 12px;
        }
        .math-equation {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            padding: 10px 0;
            border-bottom: 1px solid #222;
            overflow-x: auto;
        }
        .math-equation:last-child {
            border-bottom: none;
        }
        .math-equation .katex {
            font-size: 1.0em;
        }
        .math-symbolic {
            border-right: 1px solid #333;
            padding-right: 15px;
        }
        .math-numeric {
            color: #4ade80;
        }
        .math-numeric .katex {
            font-size: 0.95em;
        }
        .math-label {
            color: #888;
            font-size: 0.8em;
            margin-bottom: 5px;
        }
        .math-note {
            color: #666;
            font-size: 0.75em;
            margin-top: 5px;
            font-style: italic;
            grid-column: 1 / -1;
        }
        .math-header {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            padding-bottom: 8px;
            margin-bottom: 8px;
            border-bottom: 1px solid #444;
            font-size: 0.75em;
            color: #888;
        }
        .math-header span:first-child {
            border-right: 1px solid #333;
            padding-right: 15px;
        }
        .overlay-controls {
            background: #0f0f23;
            border-radius: 8px;
            padding: 12px 15px;
            margin-top: 15px;
        }
        .overlay-controls h3 {
            color: #00d4ff;
            font-size: 0.95em;
            margin-bottom: 10px;
        }
        .overlay-checkboxes {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .overlay-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .overlay-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #00d4ff;
            cursor: pointer;
        }
        .overlay-checkbox .axis-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        .overlay-checkbox label {
            font-size: 0.9em;
            color: #aaa;
            cursor: pointer;
        }
        .overlay-checkbox.disabled {
            opacity: 0.4;
        }
        .optimize-section {
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .optimize-section h3 {
            color: #00d4ff;
            font-size: 0.95em;
            margin-bottom: 12px;
        }
        .optimize-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .optimize-row label {
            font-size: 0.85em;
            color: #aaa;
            flex: 0 0 120px;
        }
        .optimize-row input[type="number"] {
            width: 70px;
            padding: 6px 8px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #1a1a2e;
            color: #fff;
            font-size: 0.9em;
            text-align: right;
        }
        .optimize-row .unit {
            font-size: 0.8em;
            color: #666;
        }
        .optimize-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: #000;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 10px;
        }
        .optimize-btn:hover {
            background: linear-gradient(135deg, #00e5ff, #00aadd);
            transform: translateY(-1px);
        }
        .optimize-btn:active {
            transform: translateY(0);
        }
        .optimize-btn:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
        }
        .sensitivity-display {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 0.9em;
            border-top: 1px solid #333;
            margin-top: 10px;
        }
        .sensitivity-value {
            color: #4ade80;
            font-weight: 600;
        }
        .sensitivity-value.warning {
            color: #fbbf24;
        }
        .sensitivity-value.danger {
            color: #f87171;
        }
        @media (max-width: 1000px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>StampFly Loop Shaping Design Tool</h1>
        <p class="subtitle">リアルタイムPID制御器設計 / Real-time PID Controller Design</p>

        <div class="tabs">
            <button class="tab calc" data-axis="calc">Calc / 計算</button>
            <button class="tab roll active" data-axis="roll">Roll</button>
            <button class="tab pitch" data-axis="pitch">Pitch</button>
            <button class="tab yaw" data-axis="yaw">Yaw</button>
            <button class="tab all" data-axis="all">All / 統合</button>
        </div>

        <div class="panel">
            <div class="single-view-params">
                <h2>プラントパラメータ / Plant Parameters <span class="axis-indicator roll" id="axis-label">Roll</span></h2>
                <div class="param-group">
                    <div class="param-row">
                        <label>慣性モーメント I</label>
                        <input type="range" id="inertia-slider" min="1" max="100" step="0.1" value="9.16">
                        <input type="number" id="inertia-input" value="9.16" step="0.1">
                        <span class="unit">×10⁻⁶ kg·m²</span>
                    </div>
                    <div class="param-row">
                        <label>モータ時定数 τₘ</label>
                        <input type="range" id="tau-slider" min="5" max="100" step="1" value="20">
                        <input type="number" id="tau-input" value="20" step="1">
                        <span class="unit">ms</span>
                    </div>
                </div>

                <h2>PIDパラメータ / PID Parameters</h2>
                <div class="param-group">
                    <div class="param-row">
                        <label>比例ゲイン Kp</label>
                        <input type="range" id="kp-slider" min="0.001" max="2" step="0.001" value="0.134">
                        <input type="number" id="kp-input" value="0.134" step="0.001">
                        <span class="unit">×10⁻³</span>
                    </div>
                    <div class="param-row">
                        <label>積分時間 Ti</label>
                        <input type="range" id="ti-slider" min="10" max="1000" step="1" value="75.6">
                        <input type="number" id="ti-input" value="75.6" step="0.1">
                        <span class="unit">ms</span>
                    </div>
                    <div class="param-row">
                        <label>微分時間 Td</label>
                        <input type="range" id="td-slider" min="1" max="200" step="0.1" value="42.6">
                        <input type="number" id="td-input" value="42.6" step="0.1">
                        <span class="unit">ms</span>
                    </div>
                    <div class="param-row">
                        <label>微分フィルタ η</label>
                        <input type="range" id="eta-slider" min="0.01" max="0.5" step="0.01" value="0.1">
                        <input type="number" id="eta-input" value="0.1" step="0.01">
                        <span class="unit"></span>
                    </div>
                </div>

                <div class="results">
                    <h3>設計結果 / Design Results</h3>
                    <div class="result-row">
                        <span>ゲイン交差周波数 ω_gc</span>
                        <span class="result-value" id="result-wgc">-- rad/s</span>
                    </div>
                    <div class="result-row">
                        <span>位相余裕 PM</span>
                        <span class="result-value" id="result-pm">-- °</span>
                    </div>
                    <div class="result-row">
                        <span>ゲイン余裕 GM</span>
                        <span class="result-value" id="result-gm">-- dB</span>
                    </div>
                    <div class="result-row">
                        <span>モータ帯域幅 ω_m</span>
                        <span class="result-value" id="result-wm">-- rad/s</span>
                    </div>
                    <div class="result-row">
                        <span>帯域幅比 ω_gc/ω_m</span>
                        <span class="result-value" id="result-ratio">-- %</span>
                    </div>
                </div>

                <div class="transfer-function">
                    <div class="tf-label">プラント G(s):</div>
                    <div class="tf-equation" id="tf-plant">G(s) = K / (s(τₘs + 1))</div>
                    <div class="tf-label" style="margin-top:10px">制御器 C(s):</div>
                    <div class="tf-equation" id="tf-controller">C(s) = Kp(1 + 1/(Ti·s) + Td·s/(ηTd·s+1))</div>
                </div>

                <div class="overlay-controls">
                    <h3>他軸を重ねて表示 / Overlay Other Axes</h3>
                    <div class="overlay-checkboxes">
                        <div class="overlay-checkbox" id="overlay-roll-container">
                            <input type="checkbox" id="overlay-roll">
                            <div class="axis-color" style="background:#ef4444"></div>
                            <label for="overlay-roll">Roll (X)</label>
                        </div>
                        <div class="overlay-checkbox" id="overlay-pitch-container">
                            <input type="checkbox" id="overlay-pitch">
                            <div class="axis-color" style="background:#22c55e"></div>
                            <label for="overlay-pitch">Pitch (Y)</label>
                        </div>
                        <div class="overlay-checkbox" id="overlay-yaw-container">
                            <input type="checkbox" id="overlay-yaw">
                            <div class="axis-color" style="background:#3b82f6"></div>
                            <label for="overlay-yaw">Yaw (Z)</label>
                        </div>
                    </div>
                </div>

                <div class="optimize-section">
                    <h3>自動最適化 / Auto Optimization</h3>
                    <div class="optimize-row">
                        <label>目標位相余裕 PM</label>
                        <input type="number" id="target-pm" value="60" step="5" min="30" max="80">
                        <span class="unit">°</span>
                    </div>
                    <div class="optimize-row">
                        <label>目標帯域幅比</label>
                        <input type="number" id="target-bw-ratio" value="30" step="5" min="10" max="50">
                        <span class="unit">% of ω_m</span>
                    </div>
                    <button class="optimize-btn" id="optimize-btn">
                        感度関数を最小化 / Minimize Sensitivity
                    </button>
                    <div class="sensitivity-display">
                        <span>感度ピーク Ms</span>
                        <span class="sensitivity-value" id="result-ms">-- dB</span>
                    </div>
                </div>
            </div>

            <div class="all-view-params">
                <h2>3軸比較 / 3-Axis Comparison</h2>
                <div class="results">
                    <h3>設計結果 / Design Results</h3>
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>パラメータ</th>
                                <th class="axis-roll">Roll</th>
                                <th class="axis-pitch">Pitch</th>
                                <th class="axis-yaw">Yaw</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>慣性 I [×10⁻⁶ kg·m²]</td>
                                <td id="all-inertia-roll">--</td>
                                <td id="all-inertia-pitch">--</td>
                                <td id="all-inertia-yaw">--</td>
                            </tr>
                            <tr>
                                <td>Kp [×10⁻³]</td>
                                <td id="all-kp-roll">--</td>
                                <td id="all-kp-pitch">--</td>
                                <td id="all-kp-yaw">--</td>
                            </tr>
                            <tr>
                                <td>Ti [ms]</td>
                                <td id="all-ti-roll">--</td>
                                <td id="all-ti-pitch">--</td>
                                <td id="all-ti-yaw">--</td>
                            </tr>
                            <tr>
                                <td>Td [ms]</td>
                                <td id="all-td-roll">--</td>
                                <td id="all-td-pitch">--</td>
                                <td id="all-td-yaw">--</td>
                            </tr>
                            <tr>
                                <td>ω_gc [rad/s]</td>
                                <td id="all-wgc-roll">--</td>
                                <td id="all-wgc-pitch">--</td>
                                <td id="all-wgc-yaw">--</td>
                            </tr>
                            <tr>
                                <td>位相余裕 PM [°]</td>
                                <td id="all-pm-roll">--</td>
                                <td id="all-pm-pitch">--</td>
                                <td id="all-pm-yaw">--</td>
                            </tr>
                            <tr>
                                <td>ゲイン余裕 GM [dB]</td>
                                <td id="all-gm-roll">--</td>
                                <td id="all-gm-pitch">--</td>
                                <td id="all-gm-yaw">--</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="legend-info" style="margin-top: 20px;">
                    <div class="legend-item">
                        <div class="legend-color" style="background:#ef4444"></div>
                        <span>Roll (X)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background:#22c55e"></div>
                        <span>Pitch (Y)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background:#3b82f6"></div>
                        <span>Yaw (Z)</span>
                    </div>
                </div>
            </div>

            <div class="calc-view-params">
                <h2>物理パラメータから伝達関数を計算 / Calculate TF from Physical Parameters</h2>

                <div class="calc-input-group">
                    <h3>機体パラメータ / Vehicle Parameters</h3>
                    <div class="param-row">
                        <label>機体質量 m</label>
                        <input type="number" id="calc-mass" value="0.035" step="0.001" min="0.001">
                        <span class="unit">kg</span>
                    </div>
                    <div class="param-row">
                        <label><span class="calc-axis-label roll">X</span>Ixx</label>
                        <input type="number" id="calc-ixx" value="9.16" step="0.01" min="0.1">
                        <span class="unit">×10⁻⁶ kg·m²</span>
                    </div>
                    <div class="param-row">
                        <label><span class="calc-axis-label pitch">Y</span>Iyy</label>
                        <input type="number" id="calc-iyy" value="13.3" step="0.01" min="0.1">
                        <span class="unit">×10⁻⁶ kg·m²</span>
                    </div>
                    <div class="param-row">
                        <label><span class="calc-axis-label yaw">Z</span>Izz</label>
                        <input type="number" id="calc-izz" value="20.4" step="0.01" min="0.1">
                        <span class="unit">×10⁻⁶ kg·m²</span>
                    </div>
                </div>

                <div class="calc-input-group">
                    <h3>モーター特性 / Motor Characteristics</h3>
                    <div class="param-row">
                        <label>巻線抵抗 Rm</label>
                        <input type="number" id="calc-rm" value="0.34" step="0.01" min="0.01">
                        <span class="unit">Ω</span>
                    </div>
                    <div class="param-row">
                        <label>回転子慣性 Jmp</label>
                        <input type="number" id="calc-jmp" value="2.01" step="0.01" min="0.01">
                        <span class="unit">×10⁻⁸ kg·m²</span>
                    </div>
                    <div class="param-row">
                        <label>トルク定数 Kt=Ke</label>
                        <input type="number" id="calc-kt" value="6.12" step="0.01" min="0.01">
                        <span class="unit">×10⁻⁴ V/(rad/s)</span>
                    </div>
                    <div style="font-size: 0.75em; color: #888; margin-top: 5px; padding-left: 140px;">
                        理想DCモータでは Kt = Ke（SI単位系）
                    </div>
                </div>

                <div class="calc-input-group">
                    <h3>プロペラ特性 / Propeller Characteristics</h3>
                    <div class="param-row">
                        <label>推力係数 Ct</label>
                        <input type="number" id="calc-ct" value="1.00" step="0.01" min="0.01">
                        <span class="unit">×10⁻⁸ N/(rad/s)²</span>
                    </div>
                    <div class="param-row">
                        <label>トルク係数 Cq</label>
                        <input type="number" id="calc-cq" value="9.71" step="0.01" min="0.01">
                        <span class="unit">×10⁻¹¹ N·m/(rad/s)²</span>
                    </div>
                </div>

                <div class="calc-input-group">
                    <h3>プロペラ配置 / Propeller Layout</h3>
                    <div style="font-size: 0.75em; color: #888; margin-bottom: 10px;">
                        重心を原点としたNED座標系 (X:前方, Y:右方) [mm]
                    </div>
                    <div class="propeller-layout">
                        <div class="prop-input-row">
                            <span class="prop-label m1">M1 (FR)</span>
                            <label>X</label>
                            <input type="number" id="prop-m1-x" value="23" step="0.1">
                            <label>Y</label>
                            <input type="number" id="prop-m1-y" value="23" step="0.1">
                            <select id="prop-m1-dir"><option value="-1">CCW</option><option value="1">CW</option></select>
                        </div>
                        <div class="prop-input-row">
                            <span class="prop-label m2">M2 (RR)</span>
                            <label>X</label>
                            <input type="number" id="prop-m2-x" value="-23" step="0.1">
                            <label>Y</label>
                            <input type="number" id="prop-m2-y" value="23" step="0.1">
                            <select id="prop-m2-dir"><option value="1" selected>CW</option><option value="-1">CCW</option></select>
                        </div>
                        <div class="prop-input-row">
                            <span class="prop-label m3">M3 (RL)</span>
                            <label>X</label>
                            <input type="number" id="prop-m3-x" value="-23" step="0.1">
                            <label>Y</label>
                            <input type="number" id="prop-m3-y" value="-23" step="0.1">
                            <select id="prop-m3-dir"><option value="-1">CCW</option><option value="1">CW</option></select>
                        </div>
                        <div class="prop-input-row">
                            <span class="prop-label m4">M4 (FL)</span>
                            <label>X</label>
                            <input type="number" id="prop-m4-x" value="23" step="0.1">
                            <label>Y</label>
                            <input type="number" id="prop-m4-y" value="-23" step="0.1">
                            <select id="prop-m4-dir"><option value="1" selected>CW</option><option value="-1">CCW</option></select>
                        </div>
                    </div>
                    <div class="calc-result-row" style="margin-top: 10px;">
                        <span>トルク/推力比 κ = Cq/Ct</span>
                        <span class="result-value" id="calc-kappa">-- ×10⁻³</span>
                    </div>
                </div>

                <div class="calc-result-group">
                    <h3>中間計算 / Intermediate Calculations</h3>
                    <div class="calc-result-row">
                        <span>モータ時定数 τm = Jmp·Rm/Kt²</span>
                        <span class="result-value" id="calc-tau-calc">-- ms</span>
                    </div>
                    <div class="calc-result-row">
                        <span>ホバリング回転数 ω₀ = √(mg/4Ct)</span>
                        <span class="result-value" id="calc-hover-omega">-- rad/s</span>
                    </div>
                    <div class="calc-result-row">
                        <span>1モーター推力 T₀ = mg/4</span>
                        <span class="result-value" id="calc-hover-thrust">-- N</span>
                    </div>
                    <div class="calc-formula" style="margin-top: 10px; font-size: 0.8em;">
                        τm = Jmp·Rm/Kt² (電気時定数を無視した近似モデル)
                    </div>
                </div>

                <div class="calc-input-group" style="background: #1a1a2e; border: 1px solid #f59e0b;">
                    <h3 style="color: #f59e0b;">モータ時定数オーバーライド / Motor Time Constant Override</h3>
                    <div class="param-row" style="align-items: center;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="calc-tau-override-enable" style="width: 16px; height: 16px; cursor: pointer;">
                            <span>手動値を使用</span>
                        </label>
                        <input type="number" id="calc-tau-override" value="20" step="1" min="1" disabled>
                        <span class="unit">ms</span>
                    </div>
                    <div style="font-size: 0.8em; color: #888; margin-top: 5px;">
                        チェック時: 手動入力値を使用 / チェックなし: 計算値 τm = Jmp·Rm/Kt² を使用
                    </div>
                </div>

                <div class="calc-result-group" style="border: 2px solid #00d4ff;">
                    <h3>伝達関数パラメータ / Transfer Function Parameters</h3>
                    <div class="calc-formula" style="margin-bottom: 15px;">
                        G(s) = K / (s(τₘs + 1)) &nbsp; where K = 1/I
                    </div>
                    <div class="calc-result-row">
                        <span><span class="calc-axis-label roll">Roll</span>K = 1/Ixx</span>
                        <span class="result-value" id="calc-k-roll">-- ×10³ rad/(N·m·s)</span>
                    </div>
                    <div class="calc-result-row">
                        <span><span class="calc-axis-label pitch">Pitch</span>K = 1/Iyy</span>
                        <span class="result-value" id="calc-k-pitch">-- ×10³ rad/(N·m·s)</span>
                    </div>
                    <div class="calc-result-row">
                        <span><span class="calc-axis-label yaw">Yaw</span>K = 1/Izz</span>
                        <span class="result-value" id="calc-k-yaw">-- ×10³ rad/(N·m·s)</span>
                    </div>
                    <div class="calc-result-row">
                        <span>モータ時定数 τm</span>
                        <span class="result-value" id="calc-tau-final">-- ms</span>
                    </div>
                    <div class="calc-result-row">
                        <span>モータ帯域幅 ωm = 1/τm</span>
                        <span class="result-value" id="calc-wm">-- rad/s</span>
                    </div>
                </div>

                <div style="display: flex; gap: 10px;">
                    <button class="apply-btn" id="apply-calc-btn" style="flex: 2;">
                        各軸に反映 / Apply to Tabs
                    </button>
                    <button class="apply-btn" id="reset-calc-btn" style="flex: 1; background: linear-gradient(135deg, #6b7280, #4b5563);">
                        リセット / Reset
                    </button>
                </div>

                <div class="transfer-function" style="margin-top: 15px;">
                    <div class="tf-label">参照元 / Reference:</div>
                    <div style="font-size: 0.85em; color: #888; margin-top: 5px;">
                        • docs/architecture/stampfly-parameters.md<br>
                        • docs/architecture/control-system.md (§6 DCモータモデル, §7 線形化と伝達関数)
                    </div>
                </div>
            </div>
        </div>

        <div class="math-panel" id="math-panel" style="display: none; grid-row: 4;">
            <h2>StampFly 伝達関数モデル / Transfer Function Models</h2>

            <div class="math-section">
                <h3>プラント伝達関数 / Plant Transfer Function</h3>
                <div class="math-header"><span>数式 / Formula</span><span>数値例 / Numerical</span></div>
                <div class="math-equation">
                    <div class="math-symbolic" id="eq-plant"></div>
                    <div class="math-numeric" id="eq-plant-num"></div>
                </div>
                <div class="math-equation">
                    <div class="math-symbolic" id="eq-plant-gain"></div>
                    <div class="math-numeric" id="eq-plant-gain-num"></div>
                </div>
            </div>

            <div class="math-section">
                <h3>DCモータモデル / DC Motor Model</h3>
                <div class="math-header"><span>数式 / Formula</span><span>数値例 / Numerical</span></div>
                <div class="math-equation">
                    <div class="math-symbolic" id="eq-motor-tau"></div>
                    <div class="math-numeric" id="eq-motor-tau-num"></div>
                </div>
            </div>

            <div class="math-section">
                <h3>PID制御器 / PID Controller</h3>
                <div class="math-header"><span>数式 / Formula</span><span>数値例 / Numerical</span></div>
                <div class="math-equation">
                    <div class="math-symbolic" id="eq-pid"></div>
                    <div class="math-numeric" id="eq-pid-num"></div>
                </div>
            </div>

            <div class="math-section">
                <h3>閉ループ特性 / Closed-Loop</h3>
                <div class="math-header"><span>数式 / Formula</span><span>説明 / Description</span></div>
                <div class="math-equation">
                    <div class="math-symbolic" id="eq-sensitivity"></div>
                    <div class="math-numeric" id="eq-sensitivity-desc"></div>
                </div>
                <div class="math-equation">
                    <div class="math-symbolic" id="eq-comp-sensitivity"></div>
                    <div class="math-numeric" id="eq-comp-sensitivity-desc"></div>
                </div>
            </div>

            <div class="math-section">
                <h3>ホバリング条件 / Hover Conditions</h3>
                <div class="math-header"><span>数式 / Formula</span><span>数値例 / Numerical</span></div>
                <div class="math-equation">
                    <div class="math-symbolic" id="eq-hover"></div>
                    <div class="math-numeric" id="eq-hover-num"></div>
                </div>
                <div class="math-equation">
                    <div class="math-symbolic" id="eq-thrust"></div>
                    <div class="math-numeric" id="eq-thrust-num"></div>
                </div>
            </div>

            <div class="math-section">
                <h3>制御アロケーション / Control Allocation</h3>
                <div style="font-size: 0.8em; color: #888; margin-bottom: 10px;">
                    [T, τ_φ, τ_θ, τ_ψ]ᵀ = B · [F₁, F₂, F₃, F₄]ᵀ
                </div>
                <div class="matrix-display">
                    <h4>アロケーション行列 B / Allocation Matrix</h4>
                    <div id="matrix-allocation"></div>
                </div>
                <div class="matrix-display">
                    <h4>ミキシング行列 B⁻¹ / Mixing Matrix</h4>
                    <div id="matrix-mixing"></div>
                </div>
            </div>
        </div>

        <div class="plots">
            <div class="plot-container">
                <div id="bode-plot"></div>
                <div class="legend-info" id="single-legend">
                    <label class="legend-item">
                        <input type="checkbox" id="show-L" checked>
                        <div class="legend-color" style="background:#3b82f6"></div>
                        <span>L(s)</span>
                    </label>
                    <label class="legend-item">
                        <input type="checkbox" id="show-G" checked>
                        <div class="legend-color" style="background:#22c55e"></div>
                        <span>G(s)</span>
                    </label>
                    <label class="legend-item">
                        <input type="checkbox" id="show-C" checked>
                        <div class="legend-color" style="background:#ef4444"></div>
                        <span>C(s)</span>
                    </label>
                    <label class="legend-item">
                        <input type="checkbox" id="show-S">
                        <div class="legend-color" style="background:#f59e0b"></div>
                        <span>S(s)</span>
                    </label>
                    <label class="legend-item">
                        <input type="checkbox" id="show-T">
                        <div class="legend-color" style="background:#a855f7"></div>
                        <span>T(s)</span>
                    </label>
                </div>
            </div>
            <div class="plot-container">
                <div class="plot-controls">
                    <label>時間範囲 / Time Range:</label>
                    <input type="range" id="time-range-slider" min="0.5" max="10" step="0.5" value="2">
                    <input type="number" id="time-range-input" value="2" step="0.5" min="0.5" max="10">
                    <span class="unit">s</span>
                </div>
                <div id="step-plot"></div>
            </div>
        </div>
    </div>

    <script>
        // Complex number operations
        const Complex = {
            create: (re, im) => ({ re, im }),
            fromPolar: (r, theta) => ({ re: r * Math.cos(theta), im: r * Math.sin(theta) }),
            add: (a, b) => ({ re: a.re + b.re, im: a.im + b.im }),
            sub: (a, b) => ({ re: a.re - b.re, im: a.im - b.im }),
            mul: (a, b) => ({
                re: a.re * b.re - a.im * b.im,
                im: a.re * b.im + a.im * b.re
            }),
            div: (a, b) => {
                const denom = b.re * b.re + b.im * b.im;
                return {
                    re: (a.re * b.re + a.im * b.im) / denom,
                    im: (a.im * b.re - a.re * b.im) / denom
                };
            },
            abs: (c) => Math.sqrt(c.re * c.re + c.im * c.im),
            arg: (c) => Math.atan2(c.im, c.re),
            scale: (c, k) => ({ re: c.re * k, im: c.im * k })
        };

        // Axis parameters storage (inertia values from stampfly-parameters.md)
        // Ixx = 9.16e-6, Iyy = 13.3e-6, Izz = 20.4e-6 kg·m²
        const axisParams = {
            roll: { inertia: 9.16, tau: 20, kp: 0.134, ti: 75.6, td: 42.6, eta: 0.1 },
            pitch: { inertia: 13.3, tau: 20, kp: 0.134, ti: 75.6, td: 42.6, eta: 0.1 },
            yaw: { inertia: 20.4, tau: 20, kp: 0.5, ti: 150, td: 50, eta: 0.1 }
        };

        // Physical parameters (from stampfly-parameters.md)
        const physicalParams = {
            Ixx: 9.16,    // Roll moment of inertia [×10⁻⁶ kg·m²]
            Iyy: 13.3,    // Pitch moment of inertia [×10⁻⁶ kg·m²]
            Izz: 20.4,    // Yaw moment of inertia [×10⁻⁶ kg·m²]
            tau_m: 20     // Motor time constant [ms]
        };

        const axisColors = {
            roll: '#ef4444',   // Red (X)
            pitch: '#22c55e',  // Green (Y)
            yaw: '#3b82f6'     // Blue (Z)
        };

        let currentAxis = 'roll';

        // Transfer function evaluation
        function evalPlant(omega, K, tau_m) {
            const jw = Complex.create(0, omega);
            const jwTau = Complex.create(0, omega * tau_m);
            const term1 = Complex.add(jwTau, Complex.create(1, 0));
            const denom = Complex.mul(jw, term1);
            return Complex.div(Complex.create(K, 0), denom);
        }

        function evalController(omega, Kp, Ti, Td, eta) {
            const jw = Complex.create(0, omega);
            const one = Complex.create(1, 0);
            const integral = Complex.div(one, Complex.scale(jw, Ti));
            const numD = Complex.scale(jw, Td);
            const denomD = Complex.add(Complex.scale(jw, eta * Td), one);
            const derivative = Complex.div(numD, denomD);
            const sum = Complex.add(Complex.add(one, integral), derivative);
            return Complex.scale(sum, Kp);
        }

        function evalOpenLoop(omega, K, tau_m, Kp, Ti, Td, eta) {
            const G = evalPlant(omega, K, tau_m);
            const C = evalController(omega, Kp, Ti, Td, eta);
            return Complex.mul(C, G);
        }

        // Calculate margins
        function calculateMargins(K, tau_m, Kp, Ti, Td, eta) {
            const omegas = [];
            for (let i = -2; i <= 4; i += 0.01) {
                omegas.push(Math.pow(10, i));
            }

            let omega_gc = null, pm = null;
            let omega_pc = null, gm_dB = null;

            for (let i = 1; i < omegas.length; i++) {
                const L_prev = evalOpenLoop(omegas[i-1], K, tau_m, Kp, Ti, Td, eta);
                const L_curr = evalOpenLoop(omegas[i], K, tau_m, Kp, Ti, Td, eta);
                const mag_prev = Complex.abs(L_prev);
                const mag_curr = Complex.abs(L_curr);

                if ((mag_prev >= 1 && mag_curr < 1) || (mag_prev < 1 && mag_curr >= 1)) {
                    const t = (1 - mag_prev) / (mag_curr - mag_prev);
                    omega_gc = omegas[i-1] + t * (omegas[i] - omegas[i-1]);
                    const L_gc = evalOpenLoop(omega_gc, K, tau_m, Kp, Ti, Td, eta);
                    pm = 180 + Complex.arg(L_gc) * 180 / Math.PI;
                    break;
                }
            }

            let prevPhase = null;
            for (let i = 0; i < omegas.length; i++) {
                const L = evalOpenLoop(omegas[i], K, tau_m, Kp, Ti, Td, eta);
                const phase = Complex.arg(L) * 180 / Math.PI;

                if (prevPhase !== null && prevPhase > -180 && phase <= -180) {
                    omega_pc = omegas[i];
                    const L_pc = evalOpenLoop(omega_pc, K, tau_m, Kp, Ti, Td, eta);
                    gm_dB = -20 * Math.log10(Complex.abs(L_pc));
                    break;
                }
                prevPhase = phase;
            }

            return { omega_gc, pm, omega_pc, gm_dB };
        }

        // Calculate peak sensitivity Ms = max|S(jω)| where S = 1/(1+L)
        function calculateSensitivity(K, tau_m, Kp, Ti, Td, eta) {
            const omegas = [];
            for (let i = -2; i <= 4; i += 0.02) {
                omegas.push(Math.pow(10, i));
            }

            let maxS = 0;
            for (const omega of omegas) {
                const L = evalOpenLoop(omega, K, tau_m, Kp, Ti, Td, eta);
                // S = 1/(1+L)
                const one = Complex.create(1, 0);
                const onePlusL = Complex.add(one, L);
                const S = Complex.div(one, onePlusL);
                const magS = Complex.abs(S);
                if (magS > maxS) {
                    maxS = magS;
                }
            }
            return maxS;
        }

        // Optimization objective function
        // Minimizes sensitivity peak while targeting specific PM and bandwidth ratio
        function objectiveFunction(params, K, tau_m, eta, targetPM, targetBWRatio) {
            const [Kp, Ti, Td] = params;

            // Constraints: parameters must be positive
            if (Kp <= 0 || Ti <= 0 || Td <= 0) {
                return 1e10;
            }

            const margins = calculateMargins(K, tau_m, Kp, Ti, Td, eta);
            const Ms = calculateSensitivity(K, tau_m, Kp, Ti, Td, eta);

            // Check stability (must have positive phase margin)
            if (margins.pm === null || margins.pm <= 0) {
                return 1e10;
            }

            const omega_m = 1 / tau_m;
            const bwRatio = margins.omega_gc ? (margins.omega_gc / omega_m * 100) : 0;

            // Objective: minimize Ms with penalties for constraint violations
            let cost = Ms;

            // Soft constraint: phase margin should be close to target
            const pmError = Math.abs(margins.pm - targetPM);
            cost += 0.1 * pmError;

            // Soft constraint: bandwidth ratio should be close to target
            const bwError = Math.abs(bwRatio - targetBWRatio);
            cost += 0.05 * bwError;

            // Penalty for very low phase margin
            if (margins.pm < 30) {
                cost += 10 * (30 - margins.pm);
            }

            // Penalty for very high bandwidth ratio (>50%)
            if (bwRatio > 50) {
                cost += 5 * (bwRatio - 50);
            }

            return cost;
        }

        // Nelder-Mead simplex optimization
        function nelderMead(objective, x0, maxIter = 500, tol = 1e-8) {
            const n = x0.length;
            const alpha = 1.0;  // reflection
            const gamma = 2.0;  // expansion
            const rho = 0.5;    // contraction
            const sigma = 0.5;  // shrink

            // Initialize simplex with larger spread
            const simplex = [x0.slice()];
            for (let i = 0; i < n; i++) {
                const point = x0.slice();
                point[i] *= 1.5;  // larger initial spread
                simplex.push(point);
            }

            // Evaluate all vertices
            let values = simplex.map(p => objective(p));

            for (let iter = 0; iter < maxIter; iter++) {
                // Sort vertices by objective value (proper paired sort)
                const paired = simplex.map((s, i) => ({ simplex: s, value: values[i] }));
                paired.sort((a, b) => a.value - b.value);
                for (let i = 0; i <= n; i++) {
                    simplex[i] = paired[i].simplex;
                    values[i] = paired[i].value;
                }

                // Check convergence
                const range = values[n] - values[0];
                if (range < tol) break;

                // Centroid of all but worst
                const centroid = new Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        centroid[j] += simplex[i][j] / n;
                    }
                }

                // Reflection
                const xr = centroid.map((c, j) => c + alpha * (c - simplex[n][j]));
                const fr = objective(xr);

                if (fr >= values[0] && fr < values[n - 1]) {
                    simplex[n] = xr;
                    values[n] = fr;
                } else if (fr < values[0]) {
                    // Expansion
                    const xe = centroid.map((c, j) => c + gamma * (xr[j] - c));
                    const fe = objective(xe);
                    if (fe < fr) {
                        simplex[n] = xe;
                        values[n] = fe;
                    } else {
                        simplex[n] = xr;
                        values[n] = fr;
                    }
                } else {
                    // Contraction
                    const xc = centroid.map((c, j) => c + rho * (simplex[n][j] - c));
                    const fc = objective(xc);
                    if (fc < values[n]) {
                        simplex[n] = xc;
                        values[n] = fc;
                    } else {
                        // Shrink
                        for (let i = 1; i <= n; i++) {
                            for (let j = 0; j < n; j++) {
                                simplex[i][j] = simplex[0][j] + sigma * (simplex[i][j] - simplex[0][j]);
                            }
                            values[i] = objective(simplex[i]);
                        }
                    }
                }
            }

            // Return best point
            return simplex[0];
        }

        // Run optimization
        function runOptimization() {
            const btn = document.getElementById('optimize-btn');
            btn.disabled = true;
            btn.textContent = '最適化中... / Optimizing...';

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                const I = parseFloat(document.getElementById('inertia-input').value) * 1e-6;
                const tau_m = parseFloat(document.getElementById('tau-input').value) / 1000;
                const eta = parseFloat(document.getElementById('eta-input').value);
                const targetPM = parseFloat(document.getElementById('target-pm').value);
                const targetBWRatio = parseFloat(document.getElementById('target-bw-ratio').value);

                const K = 1 / I;
                const omega_m = 1 / tau_m;

                // Fixed initial guess based on plant parameters (not current values)
                // This ensures consistent results regardless of current slider positions
                const targetOmegaGc = omega_m * targetBWRatio / 100;
                const Kp0 = 0.1e-3;  // Conservative initial Kp
                const Ti0 = 2 / targetOmegaGc;  // Ti based on target bandwidth
                const Td0 = 0.5 / targetOmegaGc;  // Td based on target bandwidth

                const objective = (params) => objectiveFunction(params, K, tau_m, eta, targetPM, targetBWRatio);

                // Run optimization with multiple restarts for robustness
                let bestResult = [Kp0, Ti0, Td0];
                let bestCost = objective(bestResult);

                // Try from multiple starting points
                const startPoints = [
                    [Kp0, Ti0, Td0],
                    [Kp0 * 2, Ti0, Td0],
                    [Kp0, Ti0 * 0.5, Td0 * 2],
                    [Kp0 * 0.5, Ti0 * 2, Td0 * 0.5]
                ];

                for (const start of startPoints) {
                    const result = nelderMead(objective, start, 500);
                    const cost = objective(result);
                    if (cost < bestCost) {
                        bestCost = cost;
                        bestResult = result;
                    }
                }

                const [KpOpt, TiOpt, TdOpt] = bestResult;

                // Update UI with optimized values
                document.getElementById('kp-input').value = (KpOpt * 1e3).toFixed(3);
                document.getElementById('kp-slider').value = (KpOpt * 1e3).toFixed(3);
                document.getElementById('ti-input').value = (TiOpt * 1000).toFixed(1);
                document.getElementById('ti-slider').value = (TiOpt * 1000).toFixed(1);
                document.getElementById('td-input').value = (TdOpt * 1000).toFixed(1);
                document.getElementById('td-slider').value = (TdOpt * 1000).toFixed(1);

                btn.disabled = false;
                btn.textContent = '感度関数を最小化 / Minimize Sensitivity';

                updatePlots();
            }, 50);
        }

        // Closed-loop step response (numerical simulation)
        function simulateStepResponse(K, tau_m, Kp, Ti, Td, eta, tMax, dt) {
            const t = [];
            const y = [];

            let omega_state = 0;
            let motor_state = 0;
            let integral = 0;
            let deriv_state = 0;
            let prev_error = 0;

            const target = 1;

            for (let time = 0; time <= tMax; time += dt) {
                t.push(time);
                y.push(omega_state);

                const error = target - omega_state;

                integral += error * dt / Ti;
                const deriv_raw = (error - prev_error) / dt;
                deriv_state += (deriv_raw * Td - deriv_state) * dt / (eta * Td);

                const u = Kp * (error + integral + deriv_state);

                const d_motor = (u - motor_state) / tau_m;
                motor_state += d_motor * dt;

                omega_state += motor_state * K * dt;

                prev_error = error;
            }

            return { t, y };
        }

        // Get axis parameters from storage
        function getAxisParams(axis) {
            const p = axisParams[axis];
            const I = p.inertia * 1e-6;
            const tau_m = p.tau / 1000;
            const Kp = p.kp * 1e-3;
            const Ti = p.ti / 1000;
            const Td = p.td / 1000;
            const eta = p.eta;
            const K = 1 / I;
            return { I, tau_m, Kp, Ti, Td, eta, K };
        }

        // Calculate frequency response for an axis
        function calcFreqResponse(axis, omegas) {
            const { K, tau_m, Kp, Ti, Td, eta } = getAxisParams(axis);

            const mag_L = [], phase_L = [];
            let unwrapOffset = 0;
            let prevPhase_L = null;

            for (const omega of omegas) {
                const L = evalOpenLoop(omega, K, tau_m, Kp, Ti, Td, eta);
                mag_L.push(20 * Math.log10(Complex.abs(L)));

                let ph_L = Complex.arg(L) * 180 / Math.PI;
                if (prevPhase_L !== null && ph_L - prevPhase_L > 180) {
                    unwrapOffset -= 360;
                } else if (prevPhase_L !== null && ph_L - prevPhase_L < -180) {
                    unwrapOffset += 360;
                }
                prevPhase_L = ph_L;
                phase_L.push(ph_L + unwrapOffset);
            }

            const margins = calculateMargins(K, tau_m, Kp, Ti, Td, eta);
            return { mag_L, phase_L, margins };
        }

        // Save current UI values to axis storage
        function saveCurrentParams() {
            if (currentAxis === 'all') return;
            axisParams[currentAxis] = {
                inertia: parseFloat(document.getElementById('inertia-input').value),
                tau: parseFloat(document.getElementById('tau-input').value),
                kp: parseFloat(document.getElementById('kp-input').value),
                ti: parseFloat(document.getElementById('ti-input').value),
                td: parseFloat(document.getElementById('td-input').value),
                eta: parseFloat(document.getElementById('eta-input').value)
            };
        }

        // Load axis values to UI
        function loadAxisParams(axis) {
            const p = axisParams[axis];
            document.getElementById('inertia-input').value = p.inertia;
            document.getElementById('inertia-slider').value = p.inertia;
            document.getElementById('tau-input').value = p.tau;
            document.getElementById('tau-slider').value = p.tau;
            document.getElementById('kp-input').value = p.kp;
            document.getElementById('kp-slider').value = p.kp;
            document.getElementById('ti-input').value = p.ti;
            document.getElementById('ti-slider').value = p.ti;
            document.getElementById('td-input').value = p.td;
            document.getElementById('td-slider').value = p.td;
            document.getElementById('eta-input').value = p.eta;
            document.getElementById('eta-slider').value = p.eta;
        }

        // Update single axis plot
        function updateSingleAxisPlot() {
            saveCurrentParams();

            const { I, tau_m, Kp, Ti, Td, eta, K } = getAxisParams(currentAxis);
            const omega_m = 1 / tau_m;

            const omegas = [];
            for (let i = -1; i <= 4; i += 0.02) {
                omegas.push(Math.pow(10, i));
            }

            const mag_L = [], phase_L = [];
            const mag_G = [], phase_G = [];
            const mag_C = [], phase_C = [];
            const mag_S = [], phase_S = [];  // Sensitivity function S = 1/(1+L)
            const mag_T = [], phase_T = [];  // Complementary sensitivity T = L/(1+L)

            let unwrapOffset = 0;
            let prevPhase_L = null;

            const one = Complex.create(1, 0);

            for (const omega of omegas) {
                const L = evalOpenLoop(omega, K, tau_m, Kp, Ti, Td, eta);
                const G = evalPlant(omega, K, tau_m);
                const C = evalController(omega, Kp, Ti, Td, eta);

                // S = 1/(1+L), T = L/(1+L)
                const onePlusL = Complex.add(one, L);
                const S = Complex.div(one, onePlusL);
                const T = Complex.div(L, onePlusL);

                mag_L.push(20 * Math.log10(Complex.abs(L)));
                mag_G.push(20 * Math.log10(Complex.abs(G)));
                mag_C.push(20 * Math.log10(Complex.abs(C)));
                mag_S.push(20 * Math.log10(Complex.abs(S)));
                mag_T.push(20 * Math.log10(Complex.abs(T)));

                let ph_L = Complex.arg(L) * 180 / Math.PI;
                if (prevPhase_L !== null && ph_L - prevPhase_L > 180) {
                    unwrapOffset -= 360;
                } else if (prevPhase_L !== null && ph_L - prevPhase_L < -180) {
                    unwrapOffset += 360;
                }
                prevPhase_L = ph_L;
                phase_L.push(ph_L + unwrapOffset);

                phase_G.push(Complex.arg(G) * 180 / Math.PI);
                phase_C.push(Complex.arg(C) * 180 / Math.PI);
                phase_S.push(Complex.arg(S) * 180 / Math.PI);
                phase_T.push(Complex.arg(T) * 180 / Math.PI);
            }

            const margins = calculateMargins(K, tau_m, Kp, Ti, Td, eta);

            // Update results display
            const wgcEl = document.getElementById('result-wgc');
            const pmEl = document.getElementById('result-pm');
            const gmEl = document.getElementById('result-gm');

            if (margins.omega_gc) {
                wgcEl.textContent = margins.omega_gc.toFixed(1) + ' rad/s';
                wgcEl.className = 'result-value';
            } else {
                wgcEl.textContent = 'N/A';
                wgcEl.className = 'result-value warning';
            }

            if (margins.pm !== null) {
                pmEl.textContent = margins.pm.toFixed(1) + '°';
                pmEl.className = 'result-value' + (margins.pm < 30 ? ' danger' : margins.pm < 45 ? ' warning' : '');
            } else {
                pmEl.textContent = 'N/A';
                pmEl.className = 'result-value warning';
            }

            if (margins.gm_dB !== null) {
                gmEl.textContent = margins.gm_dB.toFixed(1) + ' dB';
                gmEl.className = 'result-value' + (margins.gm_dB < 6 ? ' warning' : '');
            } else {
                gmEl.textContent = '∞ dB';
                gmEl.className = 'result-value';
            }

            document.getElementById('result-wm').textContent = omega_m.toFixed(1) + ' rad/s';

            if (margins.omega_gc) {
                const ratio = (margins.omega_gc / omega_m * 100);
                const ratioEl = document.getElementById('result-ratio');
                ratioEl.textContent = ratio.toFixed(1) + '%';
                ratioEl.className = 'result-value' + (ratio > 50 ? ' warning' : '');
            }

            // Calculate and display sensitivity peak
            const Ms = calculateSensitivity(K, tau_m, Kp, Ti, Td, eta);
            const Ms_dB = 20 * Math.log10(Ms);
            const msEl = document.getElementById('result-ms');
            msEl.textContent = Ms_dB.toFixed(1) + ' dB';
            // Ms > 6dB (2.0) is concerning, Ms > 9dB (2.8) is dangerous
            msEl.className = 'sensitivity-value' + (Ms_dB > 9 ? ' danger' : Ms_dB > 6 ? ' warning' : '');

            document.getElementById('tf-plant').textContent =
                `G(s) = ${(K/1000).toFixed(2)}×10³ / (s(${(tau_m*1000).toFixed(1)}ms·s + 1))`;

            // Bode plot
            const plotLayout = {
                paper_bgcolor: '#16213e',
                plot_bgcolor: '#0f0f23',
                font: { color: '#eee', size: 11 },
                margin: { t: 40, r: 30, b: 40, l: 60 },
                grid: { rows: 2, columns: 1, pattern: 'independent' },
                xaxis: { type: 'log', title: '', gridcolor: '#333', showline: true, linecolor: '#444' },
                xaxis2: { type: 'log', title: 'Frequency [rad/s]', gridcolor: '#333', showline: true, linecolor: '#444' },
                yaxis: { title: 'Magnitude [dB]', gridcolor: '#333', range: [-80, 120], showline: true, linecolor: '#444', domain: [0.55, 1] },
                yaxis2: { title: 'Phase [deg]', gridcolor: '#333', range: [-270, 90], showline: true, linecolor: '#444', domain: [0, 0.45] },
                showlegend: false,
                shapes: [
                    { type: 'line', x0: 0.1, x1: 10000, y0: 0, y1: 0, xref: 'x', yref: 'y', line: { color: '#666', width: 1, dash: 'dot' } },
                    { type: 'line', x0: 0.1, x1: 10000, y0: -180, y1: -180, xref: 'x2', yref: 'y2', line: { color: '#666', width: 1, dash: 'dot' } }
                ]
            };

            if (margins.omega_gc) {
                plotLayout.shapes.push({
                    type: 'line', x0: margins.omega_gc, x1: margins.omega_gc, y0: -80, y1: 120,
                    xref: 'x', yref: 'y', line: { color: '#3b82f6', width: 1, dash: 'dash' }
                });
                plotLayout.shapes.push({
                    type: 'line', x0: margins.omega_gc, x1: margins.omega_gc, y0: -270, y1: 90,
                    xref: 'x2', yref: 'y2', line: { color: '#3b82f6', width: 1, dash: 'dash' }
                });
            }

            // Check which traces to show
            const showL = document.getElementById('show-L').checked;
            const showG = document.getElementById('show-G').checked;
            const showC = document.getElementById('show-C').checked;
            const showS = document.getElementById('show-S').checked;
            const showT = document.getElementById('show-T').checked;

            const bodeData = [];

            if (showL) {
                bodeData.push({ x: omegas, y: mag_L, type: 'scatter', mode: 'lines', line: { color: '#3b82f6', width: 2.5 }, xaxis: 'x', yaxis: 'y' });
                bodeData.push({ x: omegas, y: phase_L, type: 'scatter', mode: 'lines', line: { color: '#3b82f6', width: 2.5 }, xaxis: 'x2', yaxis: 'y2' });
            }
            if (showG) {
                bodeData.push({ x: omegas, y: mag_G, type: 'scatter', mode: 'lines', line: { color: '#22c55e', width: 1.5, dash: 'dash' }, xaxis: 'x', yaxis: 'y' });
                bodeData.push({ x: omegas, y: phase_G, type: 'scatter', mode: 'lines', line: { color: '#22c55e', width: 1.5, dash: 'dash' }, xaxis: 'x2', yaxis: 'y2' });
            }
            if (showC) {
                bodeData.push({ x: omegas, y: mag_C, type: 'scatter', mode: 'lines', line: { color: '#ef4444', width: 1.5, dash: 'dashdot' }, xaxis: 'x', yaxis: 'y' });
                bodeData.push({ x: omegas, y: phase_C, type: 'scatter', mode: 'lines', line: { color: '#ef4444', width: 1.5, dash: 'dashdot' }, xaxis: 'x2', yaxis: 'y2' });
            }
            if (showS) {
                bodeData.push({ x: omegas, y: mag_S, type: 'scatter', mode: 'lines', line: { color: '#f59e0b', width: 1.5 }, xaxis: 'x', yaxis: 'y' });
                bodeData.push({ x: omegas, y: phase_S, type: 'scatter', mode: 'lines', line: { color: '#f59e0b', width: 1.5 }, xaxis: 'x2', yaxis: 'y2' });
            }
            if (showT) {
                bodeData.push({ x: omegas, y: mag_T, type: 'scatter', mode: 'lines', line: { color: '#a855f7', width: 1.5 }, xaxis: 'x', yaxis: 'y' });
                bodeData.push({ x: omegas, y: phase_T, type: 'scatter', mode: 'lines', line: { color: '#a855f7', width: 1.5 }, xaxis: 'x2', yaxis: 'y2' });
            }

            // Add overlay axes (other axes that are checked)
            const overlayAxes = ['roll', 'pitch', 'yaw'].filter(axis =>
                axis !== currentAxis && document.getElementById(`overlay-${axis}`).checked
            );

            for (const axis of overlayAxes) {
                const { mag_L: oMag, phase_L: oPhase } = calcFreqResponse(axis, omegas);
                const color = axisColors[axis];
                bodeData.push({
                    x: omegas, y: oMag, type: 'scatter', mode: 'lines',
                    line: { color, width: 1.5, dash: 'dot' }, xaxis: 'x', yaxis: 'y'
                });
                bodeData.push({
                    x: omegas, y: oPhase, type: 'scatter', mode: 'lines',
                    line: { color, width: 1.5, dash: 'dot' }, xaxis: 'x2', yaxis: 'y2'
                });
            }

            Plotly.react('bode-plot', bodeData, plotLayout, { responsive: true });

            // Step response
            const tMax = parseFloat(document.getElementById('time-range-input').value);
            const stepData = simulateStepResponse(K, tau_m, Kp, Ti, Td, eta, tMax, 0.001);

            const stepLayout = {
                paper_bgcolor: '#16213e',
                plot_bgcolor: '#0f0f23',
                font: { color: '#eee', size: 11 },
                margin: { t: 40, r: 30, b: 50, l: 60 },
                title: { text: 'Closed-Loop Step Response', font: { size: 14 } },
                xaxis: { title: 'Time [s]', gridcolor: '#333', showline: true, linecolor: '#444', range: [0, tMax] },
                yaxis: { title: 'Response', gridcolor: '#333', showline: true, linecolor: '#444', range: [0, 1.5] },
                shapes: [
                    { type: 'line', x0: 0, x1: tMax, y0: 1, y1: 1, line: { color: '#666', width: 1, dash: 'dash' } },
                    { type: 'line', x0: 0, x1: tMax, y0: 1.05, y1: 1.05, line: { color: '#ef4444', width: 1, dash: 'dot' } },
                    { type: 'line', x0: 0, x1: tMax, y0: 0.95, y1: 0.95, line: { color: '#ef4444', width: 1, dash: 'dot' } }
                ],
                showlegend: false
            };

            const stepPlotData = [
                { x: stepData.t, y: stepData.y, type: 'scatter', mode: 'lines', line: { color: '#3b82f6', width: 2 } }
            ];

            // Add overlay step responses
            for (const axis of overlayAxes) {
                const params = getAxisParams(axis);
                const oStepData = simulateStepResponse(params.K, params.tau_m, params.Kp, params.Ti, params.Td, params.eta, tMax, 0.001);
                stepPlotData.push({
                    x: oStepData.t, y: oStepData.y, type: 'scatter', mode: 'lines',
                    line: { color: axisColors[axis], width: 1.5, dash: 'dot' }
                });
            }

            Plotly.react('step-plot', stepPlotData, stepLayout, { responsive: true });
        }

        // Update all axes overlay plot
        function updateAllAxesPlot() {
            const omegas = [];
            for (let i = -1; i <= 4; i += 0.02) {
                omegas.push(Math.pow(10, i));
            }

            const axes = ['roll', 'pitch', 'yaw'];
            const bodeData = [];

            for (const axis of axes) {
                const { mag_L, phase_L, margins } = calcFreqResponse(axis, omegas);
                const color = axisColors[axis];

                bodeData.push({
                    x: omegas, y: mag_L, type: 'scatter', mode: 'lines',
                    line: { color, width: 2 }, name: axis, xaxis: 'x', yaxis: 'y'
                });
                bodeData.push({
                    x: omegas, y: phase_L, type: 'scatter', mode: 'lines',
                    line: { color, width: 2 }, name: axis, xaxis: 'x2', yaxis: 'y2'
                });

                // Update table
                const p = axisParams[axis];
                document.getElementById(`all-inertia-${axis}`).textContent = p.inertia.toFixed(2);
                document.getElementById(`all-kp-${axis}`).textContent = p.kp.toFixed(3);
                document.getElementById(`all-ti-${axis}`).textContent = p.ti.toFixed(1);
                document.getElementById(`all-td-${axis}`).textContent = p.td.toFixed(1);
                document.getElementById(`all-wgc-${axis}`).textContent = margins.omega_gc ? margins.omega_gc.toFixed(1) : 'N/A';
                document.getElementById(`all-pm-${axis}`).textContent = margins.pm !== null ? margins.pm.toFixed(1) : 'N/A';
                document.getElementById(`all-gm-${axis}`).textContent = margins.gm_dB !== null ? margins.gm_dB.toFixed(1) : '∞';
            }

            const plotLayout = {
                paper_bgcolor: '#16213e',
                plot_bgcolor: '#0f0f23',
                font: { color: '#eee', size: 11 },
                margin: { t: 40, r: 30, b: 40, l: 60 },
                grid: { rows: 2, columns: 1, pattern: 'independent' },
                xaxis: { type: 'log', title: '', gridcolor: '#333', showline: true, linecolor: '#444' },
                xaxis2: { type: 'log', title: 'Frequency [rad/s]', gridcolor: '#333', showline: true, linecolor: '#444' },
                yaxis: { title: 'Magnitude [dB]', gridcolor: '#333', range: [-80, 120], showline: true, linecolor: '#444', domain: [0.55, 1] },
                yaxis2: { title: 'Phase [deg]', gridcolor: '#333', range: [-270, 90], showline: true, linecolor: '#444', domain: [0, 0.45] },
                showlegend: false,
                shapes: [
                    { type: 'line', x0: 0.1, x1: 10000, y0: 0, y1: 0, xref: 'x', yref: 'y', line: { color: '#666', width: 1, dash: 'dot' } },
                    { type: 'line', x0: 0.1, x1: 10000, y0: -180, y1: -180, xref: 'x2', yref: 'y2', line: { color: '#666', width: 1, dash: 'dot' } }
                ]
            };

            Plotly.react('bode-plot', bodeData, plotLayout, { responsive: true });

            // Step response for all axes
            const tMax = parseFloat(document.getElementById('time-range-input').value);
            const stepPlotData = [];

            for (const axis of axes) {
                const { K, tau_m, Kp, Ti, Td, eta } = getAxisParams(axis);
                const stepData = simulateStepResponse(K, tau_m, Kp, Ti, Td, eta, tMax, 0.001);
                stepPlotData.push({
                    x: stepData.t, y: stepData.y, type: 'scatter', mode: 'lines',
                    line: { color: axisColors[axis], width: 2 }, name: axis
                });
            }

            const stepLayout = {
                paper_bgcolor: '#16213e',
                plot_bgcolor: '#0f0f23',
                font: { color: '#eee', size: 11 },
                margin: { t: 40, r: 30, b: 50, l: 60 },
                title: { text: 'Closed-Loop Step Response (All Axes)', font: { size: 14 } },
                xaxis: { title: 'Time [s]', gridcolor: '#333', showline: true, linecolor: '#444', range: [0, tMax] },
                yaxis: { title: 'Response', gridcolor: '#333', showline: true, linecolor: '#444', range: [0, 1.5] },
                shapes: [
                    { type: 'line', x0: 0, x1: tMax, y0: 1, y1: 1, line: { color: '#666', width: 1, dash: 'dash' } },
                    { type: 'line', x0: 0, x1: tMax, y0: 1.05, y1: 1.05, line: { color: '#888', width: 1, dash: 'dot' } },
                    { type: 'line', x0: 0, x1: tMax, y0: 0.95, y1: 0.95, line: { color: '#888', width: 1, dash: 'dot' } }
                ],
                showlegend: false
            };

            Plotly.react('step-plot', stepPlotData, stepLayout, { responsive: true });
        }

        // Main update function
        function updatePlots() {
            if (currentAxis === 'all') {
                updateAllAxesPlot();
            } else {
                updateSingleAxisPlot();
            }
        }

        // Update overlay checkboxes state
        function updateOverlayCheckboxes() {
            const axes = ['roll', 'pitch', 'yaw'];
            for (const axis of axes) {
                const container = document.getElementById(`overlay-${axis}-container`);
                const checkbox = document.getElementById(`overlay-${axis}`);
                if (axis === currentAxis) {
                    container.classList.add('disabled');
                    checkbox.disabled = true;
                    checkbox.checked = false;
                } else {
                    container.classList.remove('disabled');
                    checkbox.disabled = false;
                }
            }
        }

        // Calculate transfer function parameters from physical inputs
        function updateCalcResults() {
            // Read all input parameters
            // Vehicle parameters
            const m = parseFloat(document.getElementById('calc-mass').value);           // kg
            const Ixx = parseFloat(document.getElementById('calc-ixx').value) * 1e-6;   // kg·m²
            const Iyy = parseFloat(document.getElementById('calc-iyy').value) * 1e-6;   // kg·m²
            const Izz = parseFloat(document.getElementById('calc-izz').value) * 1e-6;   // kg·m²

            // Motor parameters
            const Rm = parseFloat(document.getElementById('calc-rm').value);            // Ω
            const Jmp = parseFloat(document.getElementById('calc-jmp').value) * 1e-8;   // kg·m²
            const Kt = parseFloat(document.getElementById('calc-kt').value) * 1e-4;     // V/(rad/s) = N·m/A

            // Propeller parameters
            const Ct = parseFloat(document.getElementById('calc-ct').value) * 1e-8;     // N/(rad/s)²
            const Cq = parseFloat(document.getElementById('calc-cq').value) * 1e-11;    // N·m/(rad/s)²

            // Propeller positions (mm -> m)
            const props = [
                { x: parseFloat(document.getElementById('prop-m1-x').value) / 1000,
                  y: parseFloat(document.getElementById('prop-m1-y').value) / 1000,
                  dir: parseInt(document.getElementById('prop-m1-dir').value) },
                { x: parseFloat(document.getElementById('prop-m2-x').value) / 1000,
                  y: parseFloat(document.getElementById('prop-m2-y').value) / 1000,
                  dir: parseInt(document.getElementById('prop-m2-dir').value) },
                { x: parseFloat(document.getElementById('prop-m3-x').value) / 1000,
                  y: parseFloat(document.getElementById('prop-m3-y').value) / 1000,
                  dir: parseInt(document.getElementById('prop-m3-dir').value) },
                { x: parseFloat(document.getElementById('prop-m4-x').value) / 1000,
                  y: parseFloat(document.getElementById('prop-m4-y').value) / 1000,
                  dir: parseInt(document.getElementById('prop-m4-dir').value) }
            ];

            // Torque/thrust ratio
            const kappa = Cq / Ct;

            // ============ Intermediate Calculations ============

            // Motor time constant (from DC motor model): τm = Jmp × Rm / Kt²
            // (Assuming Kt = Ke for ideal DC motor)
            const tau_m_calc = Jmp * Rm / (Kt * Kt);  // s

            // Hover conditions
            const g = 9.80665;  // m/s²
            const T0 = m * g / 4;  // Thrust per motor [N]
            const omega0 = Math.sqrt(m * g / (4 * Ct));  // Hover angular velocity [rad/s]

            // Display intermediate results
            document.getElementById('calc-tau-calc').textContent = (tau_m_calc * 1000).toFixed(2) + ' ms';
            document.getElementById('calc-hover-omega').textContent = omega0.toFixed(0) + ' rad/s';
            document.getElementById('calc-hover-thrust').textContent = (T0 * 1000).toFixed(2) + ' mN';

            // Display propeller layout results
            document.getElementById('calc-kappa').textContent = (kappa * 1000).toFixed(3) + ' ×10⁻³';

            // ============ Final Transfer Function Parameters ============

            // Use calculated or override tau_m based on checkbox
            const useOverride = document.getElementById('calc-tau-override-enable').checked;
            const tau_override = parseFloat(document.getElementById('calc-tau-override').value) / 1000; // s
            const tau_m = useOverride ? tau_override : tau_m_calc;

            // Plant gains K = 1/I for each axis
            const K_roll = 1 / Ixx;
            const K_pitch = 1 / Iyy;
            const K_yaw = 1 / Izz;

            // Motor bandwidth
            const omega_m = 1 / tau_m;

            // Display final results
            document.getElementById('calc-k-roll').textContent = (K_roll / 1000).toFixed(2) + ' ×10³ rad/(N·m·s)';
            document.getElementById('calc-k-pitch').textContent = (K_pitch / 1000).toFixed(2) + ' ×10³ rad/(N·m·s)';
            document.getElementById('calc-k-yaw').textContent = (K_yaw / 1000).toFixed(2) + ' ×10³ rad/(N·m·s)';
            const tauSource = useOverride ? '(手動)' : '(計算)';
            document.getElementById('calc-tau-final').textContent = (tau_m * 1000).toFixed(1) + ' ms ' + tauSource;
            document.getElementById('calc-wm').textContent = omega_m.toFixed(1) + ' rad/s';

            // Store calculated values for apply function and matrix rendering
            window.calcResults = {
                Ixx: parseFloat(document.getElementById('calc-ixx').value),
                Iyy: parseFloat(document.getElementById('calc-iyy').value),
                Izz: parseFloat(document.getElementById('calc-izz').value),
                tau_m: tau_m * 1000,  // ms
                props: props,
                kappa: kappa
            };
        }

        // Apply calculated values to all axes
        function applyCalcToAxes() {
            if (!window.calcResults) {
                updateCalcResults();
            }

            const { Ixx, Iyy, Izz, tau_m } = window.calcResults;

            // Update axis params with new inertia and tau values
            axisParams.roll.inertia = Ixx;
            axisParams.roll.tau = tau_m;
            axisParams.pitch.inertia = Iyy;
            axisParams.pitch.tau = tau_m;
            axisParams.yaw.inertia = Izz;
            axisParams.yaw.tau = tau_m;

            // Also update physicalParams
            physicalParams.Ixx = Ixx;
            physicalParams.Iyy = Iyy;
            physicalParams.Izz = Izz;
            physicalParams.tau_m = tau_m;

            // Visual feedback
            const btn = document.getElementById('apply-calc-btn');
            btn.textContent = '反映完了 / Applied!';
            setTimeout(() => {
                btn.textContent = '各軸に反映 / Apply to Tabs';
            }, 1500);
        }

        // Render math equations using KaTeX
        function renderMathEquations() {
            if (typeof katex === 'undefined') {
                // KaTeX not loaded yet, retry after a short delay
                setTimeout(renderMathEquations, 100);
                return;
            }

            // Get current values from inputs
            const m = parseFloat(document.getElementById('calc-mass').value);
            const Ixx = parseFloat(document.getElementById('calc-ixx').value);
            const Iyy = parseFloat(document.getElementById('calc-iyy').value);
            const Izz = parseFloat(document.getElementById('calc-izz').value);
            const Rm = parseFloat(document.getElementById('calc-rm').value);
            const Jmp = parseFloat(document.getElementById('calc-jmp').value);
            const Kt = parseFloat(document.getElementById('calc-kt').value);
            const Ct = parseFloat(document.getElementById('calc-ct').value);

            // Calculate derived values
            const K_roll = (1 / (Ixx * 1e-6) / 1000).toFixed(1);
            const K_pitch = (1 / (Iyy * 1e-6) / 1000).toFixed(1);
            const K_yaw = (1 / (Izz * 1e-6) / 1000).toFixed(1);
            const g = 9.80665;
            const omega0 = Math.sqrt(m * g / (4 * Ct * 1e-8)).toFixed(0);
            const T0 = (m * g / 4 * 1000).toFixed(2);

            // τm: use override value if checkbox is checked, otherwise calculate
            const useOverride = document.getElementById('calc-tau-override-enable').checked;
            const tau_m_calc = Jmp * 1e-8 * Rm / Math.pow(Kt * 1e-4, 2) * 1000;
            const tau_override = parseFloat(document.getElementById('calc-tau-override').value);
            const tau_m = (useOverride ? tau_override : tau_m_calc).toFixed(2);

            // Symbolic equations (left column)
            const symbolic = {
                'eq-plant': 'G(s) = \\frac{K}{s(\\tau_m s + 1)}',
                'eq-plant-gain': 'K = \\frac{1}{I}',
                'eq-motor-tau': '\\tau_m = \\frac{J_{mp} \\cdot R_m}{K_t^2}',
                'eq-pid': 'C(s) = K_p \\left( 1 + \\frac{1}{T_i s} + \\frac{T_d s}{\\eta T_d s + 1} \\right)',
                'eq-sensitivity': 'S(s) = \\frac{1}{1 + L(s)}',
                'eq-comp-sensitivity': 'T(s) = \\frac{L(s)}{1 + L(s)}',
                'eq-hover': '\\omega_0 = \\sqrt{\\frac{mg}{4 C_t}}',
                'eq-thrust': 'T_0 = \\frac{mg}{4}'
            };

            // Numeric equations (right column) - with actual values
            const numeric = {
                'eq-plant-num': `G(s) = \\frac{${K_roll} \\times 10^3}{s(${tau_m} \\times 10^{-3} s + 1)}`,
                'eq-plant-gain-num': `K_{roll}=${K_roll}, \\quad K_{pitch}=${K_pitch}, \\quad K_{yaw}=${K_yaw} \\; [\\times 10^3]`,
                'eq-motor-tau-num': `\\tau_m = \\frac{${Jmp} \\times 10^{-8} \\cdot ${Rm}}{(${Kt} \\times 10^{-4})^2} = ${tau_m} \\text{ ms}`,
                'eq-pid-num': `K_p, T_i, T_d, \\eta \\text{ は各軸タブで設定}`,
                'eq-sensitivity-desc': '\\text{外乱抑制特性（低周波で小さく）}',
                'eq-comp-sensitivity-desc': '\\text{目標値追従特性（帯域内で1に近く）}',
                'eq-hover-num': `\\omega_0 = \\sqrt{\\frac{${m} \\times ${g.toFixed(2)}}{4 \\times ${Ct} \\times 10^{-8}}} = ${omega0} \\text{ rad/s}`,
                'eq-thrust-num': `T_0 = \\frac{${m} \\times ${g.toFixed(2)}}{4} = ${T0} \\text{ mN}`
            };

            // Render all equations
            const allEquations = { ...symbolic, ...numeric };

            for (const [id, latex] of Object.entries(allEquations)) {
                const element = document.getElementById(id);
                if (element) {
                    try {
                        katex.render(latex, element, {
                            displayMode: true,
                            throwOnError: false
                        });
                    } catch (e) {
                        console.error('KaTeX error for', id, e);
                    }
                }
            }

            // Render allocation and mixing matrices
            renderAllocationMatrices();
        }

        // Calculate and render allocation/mixing matrices
        function renderAllocationMatrices() {
            if (typeof katex === 'undefined' || !window.calcResults) return;

            const { props, kappa } = window.calcResults;
            if (!props) return;

            // Build allocation matrix B: [T, τ_φ, τ_θ, τ_ψ]ᵀ = B × [F1, F2, F3, F4]ᵀ
            // Row 1: Thrust (all positive)
            // Row 2: Roll moment (τ_φ = Σ yi × Fi)
            // Row 3: Pitch moment (τ_θ = -Σ xi × Fi)
            // Row 4: Yaw moment (τ_ψ = Σ σi × κ × Fi, σ=+1 for CCW, -1 for CW)
            const B = [
                [1, 1, 1, 1],
                [props[0].y, props[1].y, props[2].y, props[3].y],
                [-props[0].x, -props[1].x, -props[2].x, -props[3].x],
                [-props[0].dir * kappa, -props[1].dir * kappa, -props[2].dir * kappa, -props[3].dir * kappa]
            ];

            // Calculate inverse (mixing matrix)
            const Binv = invertMatrix4x4(B);

            // Format matrix for KaTeX (convert to mm for display)
            function formatVal(v, scale = 1) {
                const val = v * scale;
                if (Math.abs(val) < 0.0001) return '0';
                return val.toFixed(3).replace(/\.?0+$/, '');
            }

            // Allocation matrix LaTeX (values in m for position, unitless for thrust)
            const B_latex = `\\begin{bmatrix}
                1 & 1 & 1 & 1 \\\\
                ${formatVal(B[1][0]*1000)} & ${formatVal(B[1][1]*1000)} & ${formatVal(B[1][2]*1000)} & ${formatVal(B[1][3]*1000)} \\\\
                ${formatVal(B[2][0]*1000)} & ${formatVal(B[2][1]*1000)} & ${formatVal(B[2][2]*1000)} & ${formatVal(B[2][3]*1000)} \\\\
                ${formatVal(B[3][0]*1000)} & ${formatVal(B[3][1]*1000)} & ${formatVal(B[3][2]*1000)} & ${formatVal(B[3][3]*1000)}
            \\end{bmatrix} \\times 10^{-3}`;

            // Mixing matrix LaTeX
            const Binv_latex = Binv ? `\\begin{bmatrix}
                ${formatVal(Binv[0][0])} & ${formatVal(Binv[0][1])} & ${formatVal(Binv[0][2])} & ${formatVal(Binv[0][3])} \\\\
                ${formatVal(Binv[1][0])} & ${formatVal(Binv[1][1])} & ${formatVal(Binv[1][2])} & ${formatVal(Binv[1][3])} \\\\
                ${formatVal(Binv[2][0])} & ${formatVal(Binv[2][1])} & ${formatVal(Binv[2][2])} & ${formatVal(Binv[2][3])} \\\\
                ${formatVal(Binv[3][0])} & ${formatVal(Binv[3][1])} & ${formatVal(Binv[3][2])} & ${formatVal(Binv[3][3])}
            \\end{bmatrix}` : '\\text{(singular matrix)}';

            try {
                katex.render(B_latex, document.getElementById('matrix-allocation'), {
                    displayMode: true, throwOnError: false
                });
                katex.render(Binv_latex, document.getElementById('matrix-mixing'), {
                    displayMode: true, throwOnError: false
                });
            } catch (e) {
                console.error('KaTeX matrix error', e);
            }
        }

        // 4x4 matrix inversion
        function invertMatrix4x4(m) {
            const inv = [];
            for (let i = 0; i < 4; i++) inv[i] = [0, 0, 0, 0];

            // Calculate determinant and adjugate
            const det =
                m[0][0] * (m[1][1] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) -
                           m[1][2] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) +
                           m[1][3] * (m[2][1] * m[3][2] - m[2][2] * m[3][1])) -
                m[0][1] * (m[1][0] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) -
                           m[1][2] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
                           m[1][3] * (m[2][0] * m[3][2] - m[2][2] * m[3][0])) +
                m[0][2] * (m[1][0] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) -
                           m[1][1] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
                           m[1][3] * (m[2][0] * m[3][1] - m[2][1] * m[3][0])) -
                m[0][3] * (m[1][0] * (m[2][1] * m[3][2] - m[2][2] * m[3][1]) -
                           m[1][1] * (m[2][0] * m[3][2] - m[2][2] * m[3][0]) +
                           m[1][2] * (m[2][0] * m[3][1] - m[2][1] * m[3][0]));

            if (Math.abs(det) < 1e-12) return null;

            // Cofactor matrix (transposed = adjugate)
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const sub = [];
                    for (let si = 0; si < 4; si++) {
                        if (si === i) continue;
                        const row = [];
                        for (let sj = 0; sj < 4; sj++) {
                            if (sj === j) continue;
                            row.push(m[si][sj]);
                        }
                        sub.push(row);
                    }
                    const minor = sub[0][0] * (sub[1][1] * sub[2][2] - sub[1][2] * sub[2][1]) -
                                  sub[0][1] * (sub[1][0] * sub[2][2] - sub[1][2] * sub[2][0]) +
                                  sub[0][2] * (sub[1][0] * sub[2][1] - sub[1][1] * sub[2][0]);
                    const sign = ((i + j) % 2 === 0) ? 1 : -1;
                    inv[j][i] = sign * minor / det;
                }
            }
            return inv;
        }

        // Reset calculation tab to default values (from stampfly-parameters.md)
        function resetCalcDefaults() {
            const defaults = {
                'calc-mass': 0.035,        // kg
                'calc-ixx': 9.16,          // ×10⁻⁶ kg·m²
                'calc-iyy': 13.3,          // ×10⁻⁶ kg·m²
                'calc-izz': 20.4,          // ×10⁻⁶ kg·m²
                'calc-rm': 0.34,           // Ω
                'calc-jmp': 2.01,          // ×10⁻⁸ kg·m²
                'calc-kt': 6.12,           // ×10⁻⁴ V/(rad/s)
                'calc-ct': 1.00,           // ×10⁻⁸ N/(rad/s)²
                'calc-cq': 9.71,           // ×10⁻¹¹ N·m/(rad/s)²
                'calc-tau-override': 20,   // ms
                // Propeller positions (mm)
                'prop-m1-x': 23, 'prop-m1-y': 23,
                'prop-m2-x': -23, 'prop-m2-y': 23,
                'prop-m3-x': -23, 'prop-m3-y': -23,
                'prop-m4-x': 23, 'prop-m4-y': -23
            };

            for (const [id, value] of Object.entries(defaults)) {
                document.getElementById(id).value = value;
            }

            // Reset rotation directions
            document.getElementById('prop-m1-dir').value = '-1';  // CCW
            document.getElementById('prop-m2-dir').value = '1';   // CW
            document.getElementById('prop-m3-dir').value = '-1';  // CCW
            document.getElementById('prop-m4-dir').value = '1';   // CW

            // Reset override checkbox to unchecked (use calculated value by default)
            document.getElementById('calc-tau-override-enable').checked = false;
            document.getElementById('calc-tau-override').disabled = true;

            updateCalcResults();
            renderAllocationMatrices();

            // Visual feedback
            const btn = document.getElementById('reset-calc-btn');
            btn.textContent = 'リセット完了!';
            setTimeout(() => {
                btn.textContent = 'リセット / Reset';
            }, 1000);
        }

        // Switch axis
        function switchAxis(axis) {
            // Save current params before switching
            saveCurrentParams();

            currentAxis = axis;

            // Update tab UI
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.tab[data-axis="${axis}"]`).classList.add('active');

            // Update axis indicator
            const axisLabel = document.getElementById('axis-label');
            if (axis !== 'all' && axis !== 'calc') {
                axisLabel.textContent = axis.charAt(0).toUpperCase() + axis.slice(1);
                axisLabel.className = `axis-indicator ${axis}`;
            }

            // Toggle panel visibility
            const singleParams = document.querySelector('.single-view-params');
            const allParams = document.querySelector('.all-view-params');
            const calcParams = document.querySelector('.calc-view-params');
            const singleLegend = document.getElementById('single-legend');
            const plotsSection = document.querySelector('.plots');
            const mathPanel = document.getElementById('math-panel');

            // Hide all first
            singleParams.classList.add('hidden');
            allParams.classList.remove('visible');
            calcParams.classList.remove('visible');
            mathPanel.style.display = 'none';

            if (axis === 'calc') {
                calcParams.classList.add('visible');
                singleLegend.style.display = 'none';
                plotsSection.style.display = 'none';
                mathPanel.style.display = 'block';
                updateCalcResults();
                renderMathEquations();
            } else if (axis === 'all') {
                allParams.classList.add('visible');
                singleLegend.style.display = 'none';
                plotsSection.style.display = 'flex';
                updatePlots();
            } else {
                singleParams.classList.remove('hidden');
                singleLegend.style.display = 'flex';
                plotsSection.style.display = 'flex';
                loadAxisParams(axis);
                updateOverlayCheckboxes();
                updatePlots();
            }
        }

        // Sync slider and input
        function syncInputs(sliderId, inputId) {
            const slider = document.getElementById(sliderId);
            const input = document.getElementById(inputId);

            slider.addEventListener('input', () => {
                input.value = slider.value;
                updatePlots();
            });

            input.addEventListener('input', () => {
                slider.value = input.value;
                updatePlots();
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            syncInputs('inertia-slider', 'inertia-input');
            syncInputs('tau-slider', 'tau-input');
            syncInputs('kp-slider', 'kp-input');
            syncInputs('ti-slider', 'ti-input');
            syncInputs('td-slider', 'td-input');
            syncInputs('eta-slider', 'eta-input');
            syncInputs('time-range-slider', 'time-range-input');

            // Overlay checkbox handlers
            ['roll', 'pitch', 'yaw'].forEach(axis => {
                document.getElementById(`overlay-${axis}`).addEventListener('change', updatePlots);
            });

            // Bode plot trace visibility checkbox handlers
            ['show-L', 'show-G', 'show-C', 'show-S', 'show-T'].forEach(id => {
                document.getElementById(id).addEventListener('change', updatePlots);
            });

            // Initialize overlay checkboxes state
            updateOverlayCheckboxes();

            // Tab click handlers
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    switchAxis(tab.dataset.axis);
                });
            });

            // Optimize button handler
            document.getElementById('optimize-btn').addEventListener('click', runOptimization);

            // Calc tab input handlers - all physical parameter inputs
            [
                'calc-mass', 'calc-ixx', 'calc-iyy', 'calc-izz',              // Vehicle
                'calc-rm', 'calc-jmp', 'calc-kt',                              // Motor
                'calc-ct', 'calc-cq',                                          // Propeller
                'calc-tau-override',                                           // Time constant override
                'prop-m1-x', 'prop-m1-y', 'prop-m2-x', 'prop-m2-y',           // Propeller positions
                'prop-m3-x', 'prop-m3-y', 'prop-m4-x', 'prop-m4-y'
            ].forEach(id => {
                document.getElementById(id).addEventListener('input', updateCalcAndMatrices);
            });

            // Propeller direction selects
            ['prop-m1-dir', 'prop-m2-dir', 'prop-m3-dir', 'prop-m4-dir'].forEach(id => {
                document.getElementById(id).addEventListener('change', updateCalcAndMatrices);
            });

            function updateCalcAndMatrices() {
                updateCalcResults();
                renderAllocationMatrices();
                renderMathEquations();
            }

            // Override checkbox handler - enable/disable override input and update calculation
            document.getElementById('calc-tau-override-enable').addEventListener('change', function() {
                const overrideInput = document.getElementById('calc-tau-override');
                overrideInput.disabled = !this.checked;
                // Update all calculations when checkbox changes
                updateCalcAndMatrices();
            });

            // Apply calc button handler
            document.getElementById('apply-calc-btn').addEventListener('click', applyCalcToAxes);

            // Reset calc button handler
            document.getElementById('reset-calc-btn').addEventListener('click', resetCalcDefaults);

            // Function to calculate and set plot heights
            function resizePlots() {
                // Get viewport height
                const vh = window.innerHeight;

                // Calculate header heights (title + subtitle + tabs + gaps)
                const headerHeight = 120;
                const containerPadding = 30;
                const plotGap = 15;
                const plotContainerPadding = 24; // 12px * 2
                const legendHeight = 35;
                const controlsHeight = 45;

                // Available height for plots area
                const availableHeight = vh - headerHeight - containerPadding;

                // Each plot container gets half (minus gap)
                const containerHeight = (availableHeight - plotGap) / 2;

                // Plot height = container - padding - extra elements
                const bodeHeight = containerHeight - plotContainerPadding - legendHeight;
                const stepHeight = containerHeight - plotContainerPadding - controlsHeight;

                document.getElementById('bode-plot').style.height = Math.max(200, bodeHeight) + 'px';
                document.getElementById('step-plot').style.height = Math.max(200, stepHeight) + 'px';

                Plotly.Plots.resize('bode-plot');
                Plotly.Plots.resize('step-plot');
            }

            // Resize plots when window resizes
            window.addEventListener('resize', resizePlots);

            updatePlots();

            // Initial resize after layout settles
            setTimeout(resizePlots, 100);
        });
    </script>
</body>
</html>
