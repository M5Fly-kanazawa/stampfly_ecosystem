<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StampFly Loop Shaping Design Tool</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }
        .container {
            display: grid;
            grid-template-columns: 600px 1fr;
            gap: 20px;
            padding: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }
        h1 {
            grid-column: 1 / -1;
            text-align: center;
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 1.8em;
        }
        .subtitle {
            grid-column: 1 / -1;
            text-align: center;
            color: #888;
            margin-bottom: 20px;
            font-size: 0.9em;
        }
        /* Tab styles */
        .tabs {
            grid-column: 1 / -1;
            display: flex;
            gap: 4px;
            margin-bottom: 10px;
            background: #16213e;
            padding: 8px;
            border-radius: 12px;
            justify-content: center;
        }
        .tab {
            padding: 12px 32px;
            border: none;
            background: transparent;
            color: #888;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
        }
        .tab:hover {
            background: #0f0f23;
            color: #ccc;
        }
        .tab.active {
            background: #00d4ff;
            color: #000;
        }
        .tab.roll { border-left: 4px solid #ef4444; }
        .tab.pitch { border-left: 4px solid #22c55e; }
        .tab.yaw { border-left: 4px solid #3b82f6; }
        .tab.all { border-left: 4px solid #8b5cf6; }
        .tab.active.roll { background: #ef4444; }
        .tab.active.pitch { background: #22c55e; }
        .tab.active.yaw { background: #3b82f6; }
        .tab.active.all { background: #8b5cf6; }
        .panel {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .panel h2 {
            color: #00d4ff;
            font-size: 1.1em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        .axis-indicator {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-left: 10px;
            color: #000;
            font-weight: bold;
        }
        .axis-indicator.roll { background: #ef4444; }
        .axis-indicator.pitch { background: #22c55e; }
        .axis-indicator.yaw { background: #3b82f6; }
        .param-group {
            margin-bottom: 20px;
        }
        .param-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 10px;
        }
        .param-row label {
            flex: 0 0 140px;
            font-size: 0.9em;
            color: #aaa;
        }
        .param-row input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        .param-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
        }
        .param-row input[type="number"] {
            width: 90px;
            padding: 6px 8px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #0f0f23;
            color: #fff;
            font-size: 0.9em;
            text-align: right;
        }
        .param-row .unit {
            flex: 0 0 60px;
            font-size: 0.8em;
            color: #666;
        }
        .results {
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .results h3 {
            color: #00d4ff;
            font-size: 0.95em;
            margin-bottom: 10px;
        }
        .result-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #222;
            font-size: 0.9em;
        }
        .result-row:last-child {
            border-bottom: none;
        }
        .result-value {
            color: #4ade80;
            font-weight: 600;
        }
        .result-value.warning {
            color: #fbbf24;
        }
        .result-value.danger {
            color: #f87171;
        }
        /* All tab results table */
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.85em;
        }
        .results-table th, .results-table td {
            padding: 8px 6px;
            text-align: center;
            border-bottom: 1px solid #333;
        }
        .results-table th {
            color: #888;
            font-weight: normal;
        }
        .results-table th:first-child, .results-table td:first-child {
            text-align: left;
        }
        .results-table .axis-roll { color: #ef4444; }
        .results-table .axis-pitch { color: #22c55e; }
        .results-table .axis-yaw { color: #3b82f6; }
        .plots {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .plot-container {
            background: #16213e;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .plot-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: #0f0f23;
            border-radius: 8px;
        }
        .plot-controls label {
            font-size: 0.9em;
            color: #aaa;
        }
        .plot-controls input[type="range"] {
            flex: 1;
            max-width: 200px;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        .plot-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
        }
        .plot-controls input[type="number"] {
            width: 70px;
            padding: 6px 8px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #1a1a2e;
            color: #fff;
            font-size: 0.9em;
            text-align: right;
        }
        .plot-controls .unit {
            font-size: 0.8em;
            color: #666;
        }
        #bode-plot, #step-plot {
            width: 100%;
            height: 400px;
        }
        .transfer-function {
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.6;
        }
        .tf-label {
            color: #888;
            margin-bottom: 5px;
        }
        .tf-equation {
            color: #4ade80;
        }
        .legend-info {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.85em;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }
        .all-view-params {
            display: none;
        }
        .all-view-params.visible {
            display: block;
        }
        .single-view-params {
            display: block;
        }
        .single-view-params.hidden {
            display: none;
        }
        .overlay-controls {
            background: #0f0f23;
            border-radius: 8px;
            padding: 12px 15px;
            margin-top: 15px;
        }
        .overlay-controls h3 {
            color: #00d4ff;
            font-size: 0.95em;
            margin-bottom: 10px;
        }
        .overlay-checkboxes {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .overlay-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .overlay-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #00d4ff;
            cursor: pointer;
        }
        .overlay-checkbox .axis-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        .overlay-checkbox label {
            font-size: 0.9em;
            color: #aaa;
            cursor: pointer;
        }
        .overlay-checkbox.disabled {
            opacity: 0.4;
        }
        .optimize-section {
            background: #0f0f23;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        .optimize-section h3 {
            color: #00d4ff;
            font-size: 0.95em;
            margin-bottom: 12px;
        }
        .optimize-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .optimize-row label {
            font-size: 0.85em;
            color: #aaa;
            flex: 0 0 120px;
        }
        .optimize-row input[type="number"] {
            width: 70px;
            padding: 6px 8px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #1a1a2e;
            color: #fff;
            font-size: 0.9em;
            text-align: right;
        }
        .optimize-row .unit {
            font-size: 0.8em;
            color: #666;
        }
        .optimize-btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: #000;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 10px;
        }
        .optimize-btn:hover {
            background: linear-gradient(135deg, #00e5ff, #00aadd);
            transform: translateY(-1px);
        }
        .optimize-btn:active {
            transform: translateY(0);
        }
        .optimize-btn:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
        }
        .sensitivity-display {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 0.9em;
            border-top: 1px solid #333;
            margin-top: 10px;
        }
        .sensitivity-value {
            color: #4ade80;
            font-weight: 600;
        }
        .sensitivity-value.warning {
            color: #fbbf24;
        }
        .sensitivity-value.danger {
            color: #f87171;
        }
        @media (max-width: 1000px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>StampFly Loop Shaping Design Tool</h1>
        <p class="subtitle">リアルタイムPID制御器設計 / Real-time PID Controller Design</p>

        <div class="tabs">
            <button class="tab roll active" data-axis="roll">Roll</button>
            <button class="tab pitch" data-axis="pitch">Pitch</button>
            <button class="tab yaw" data-axis="yaw">Yaw</button>
            <button class="tab all" data-axis="all">All / 統合</button>
        </div>

        <div class="panel">
            <div class="single-view-params">
                <h2>プラントパラメータ / Plant Parameters <span class="axis-indicator roll" id="axis-label">Roll</span></h2>
                <div class="param-group">
                    <div class="param-row">
                        <label>慣性モーメント I</label>
                        <input type="range" id="inertia-slider" min="1" max="100" step="0.1" value="9.16">
                        <input type="number" id="inertia-input" value="9.16" step="0.1">
                        <span class="unit">×10⁻⁶ kg·m²</span>
                    </div>
                    <div class="param-row">
                        <label>モータ時定数 τₘ</label>
                        <input type="range" id="tau-slider" min="5" max="100" step="1" value="20">
                        <input type="number" id="tau-input" value="20" step="1">
                        <span class="unit">ms</span>
                    </div>
                </div>

                <h2>PIDパラメータ / PID Parameters</h2>
                <div class="param-group">
                    <div class="param-row">
                        <label>比例ゲイン Kp</label>
                        <input type="range" id="kp-slider" min="0.001" max="2" step="0.001" value="0.134">
                        <input type="number" id="kp-input" value="0.134" step="0.001">
                        <span class="unit">×10⁻³</span>
                    </div>
                    <div class="param-row">
                        <label>積分時間 Ti</label>
                        <input type="range" id="ti-slider" min="10" max="1000" step="1" value="75.6">
                        <input type="number" id="ti-input" value="75.6" step="0.1">
                        <span class="unit">ms</span>
                    </div>
                    <div class="param-row">
                        <label>微分時間 Td</label>
                        <input type="range" id="td-slider" min="1" max="200" step="0.1" value="42.6">
                        <input type="number" id="td-input" value="42.6" step="0.1">
                        <span class="unit">ms</span>
                    </div>
                    <div class="param-row">
                        <label>微分フィルタ η</label>
                        <input type="range" id="eta-slider" min="0.01" max="0.5" step="0.01" value="0.1">
                        <input type="number" id="eta-input" value="0.1" step="0.01">
                        <span class="unit"></span>
                    </div>
                </div>

                <div class="results">
                    <h3>設計結果 / Design Results</h3>
                    <div class="result-row">
                        <span>ゲイン交差周波数 ω_gc</span>
                        <span class="result-value" id="result-wgc">-- rad/s</span>
                    </div>
                    <div class="result-row">
                        <span>位相余裕 PM</span>
                        <span class="result-value" id="result-pm">-- °</span>
                    </div>
                    <div class="result-row">
                        <span>ゲイン余裕 GM</span>
                        <span class="result-value" id="result-gm">-- dB</span>
                    </div>
                    <div class="result-row">
                        <span>モータ帯域幅 ω_m</span>
                        <span class="result-value" id="result-wm">-- rad/s</span>
                    </div>
                    <div class="result-row">
                        <span>帯域幅比 ω_gc/ω_m</span>
                        <span class="result-value" id="result-ratio">-- %</span>
                    </div>
                </div>

                <div class="transfer-function">
                    <div class="tf-label">プラント G(s):</div>
                    <div class="tf-equation" id="tf-plant">G(s) = K / (s(τₘs + 1))</div>
                    <div class="tf-label" style="margin-top:10px">制御器 C(s):</div>
                    <div class="tf-equation" id="tf-controller">C(s) = Kp(1 + 1/(Ti·s) + Td·s/(ηTd·s+1))</div>
                </div>

                <div class="overlay-controls">
                    <h3>他軸を重ねて表示 / Overlay Other Axes</h3>
                    <div class="overlay-checkboxes">
                        <div class="overlay-checkbox" id="overlay-roll-container">
                            <input type="checkbox" id="overlay-roll">
                            <div class="axis-color" style="background:#ef4444"></div>
                            <label for="overlay-roll">Roll (X)</label>
                        </div>
                        <div class="overlay-checkbox" id="overlay-pitch-container">
                            <input type="checkbox" id="overlay-pitch">
                            <div class="axis-color" style="background:#22c55e"></div>
                            <label for="overlay-pitch">Pitch (Y)</label>
                        </div>
                        <div class="overlay-checkbox" id="overlay-yaw-container">
                            <input type="checkbox" id="overlay-yaw">
                            <div class="axis-color" style="background:#3b82f6"></div>
                            <label for="overlay-yaw">Yaw (Z)</label>
                        </div>
                    </div>
                </div>

                <div class="optimize-section">
                    <h3>自動最適化 / Auto Optimization</h3>
                    <div class="optimize-row">
                        <label>目標位相余裕 PM</label>
                        <input type="number" id="target-pm" value="60" step="5" min="30" max="80">
                        <span class="unit">°</span>
                    </div>
                    <div class="optimize-row">
                        <label>目標帯域幅比</label>
                        <input type="number" id="target-bw-ratio" value="30" step="5" min="10" max="50">
                        <span class="unit">% of ω_m</span>
                    </div>
                    <button class="optimize-btn" id="optimize-btn">
                        感度関数を最小化 / Minimize Sensitivity
                    </button>
                    <div class="sensitivity-display">
                        <span>感度ピーク Ms</span>
                        <span class="sensitivity-value" id="result-ms">-- dB</span>
                    </div>
                </div>
            </div>

            <div class="all-view-params">
                <h2>3軸比較 / 3-Axis Comparison</h2>
                <div class="results">
                    <h3>設計結果 / Design Results</h3>
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>パラメータ</th>
                                <th class="axis-roll">Roll</th>
                                <th class="axis-pitch">Pitch</th>
                                <th class="axis-yaw">Yaw</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>慣性 I [×10⁻⁶ kg·m²]</td>
                                <td id="all-inertia-roll">--</td>
                                <td id="all-inertia-pitch">--</td>
                                <td id="all-inertia-yaw">--</td>
                            </tr>
                            <tr>
                                <td>Kp [×10⁻³]</td>
                                <td id="all-kp-roll">--</td>
                                <td id="all-kp-pitch">--</td>
                                <td id="all-kp-yaw">--</td>
                            </tr>
                            <tr>
                                <td>Ti [ms]</td>
                                <td id="all-ti-roll">--</td>
                                <td id="all-ti-pitch">--</td>
                                <td id="all-ti-yaw">--</td>
                            </tr>
                            <tr>
                                <td>Td [ms]</td>
                                <td id="all-td-roll">--</td>
                                <td id="all-td-pitch">--</td>
                                <td id="all-td-yaw">--</td>
                            </tr>
                            <tr>
                                <td>ω_gc [rad/s]</td>
                                <td id="all-wgc-roll">--</td>
                                <td id="all-wgc-pitch">--</td>
                                <td id="all-wgc-yaw">--</td>
                            </tr>
                            <tr>
                                <td>位相余裕 PM [°]</td>
                                <td id="all-pm-roll">--</td>
                                <td id="all-pm-pitch">--</td>
                                <td id="all-pm-yaw">--</td>
                            </tr>
                            <tr>
                                <td>ゲイン余裕 GM [dB]</td>
                                <td id="all-gm-roll">--</td>
                                <td id="all-gm-pitch">--</td>
                                <td id="all-gm-yaw">--</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="legend-info" style="margin-top: 20px;">
                    <div class="legend-item">
                        <div class="legend-color" style="background:#ef4444"></div>
                        <span>Roll (X)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background:#22c55e"></div>
                        <span>Pitch (Y)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background:#3b82f6"></div>
                        <span>Yaw (Z)</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="plots">
            <div class="plot-container">
                <div id="bode-plot"></div>
                <div class="legend-info" id="single-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background:#3b82f6"></div>
                        <span>開ループ L(s)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background:#22c55e"></div>
                        <span>プラント G(s)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background:#ef4444"></div>
                        <span>制御器 C(s)</span>
                    </div>
                </div>
            </div>
            <div class="plot-container">
                <div class="plot-controls">
                    <label>時間範囲 / Time Range:</label>
                    <input type="range" id="time-range-slider" min="0.5" max="10" step="0.5" value="2">
                    <input type="number" id="time-range-input" value="2" step="0.5" min="0.5" max="10">
                    <span class="unit">s</span>
                </div>
                <div id="step-plot"></div>
            </div>
        </div>
    </div>

    <script>
        // Complex number operations
        const Complex = {
            create: (re, im) => ({ re, im }),
            fromPolar: (r, theta) => ({ re: r * Math.cos(theta), im: r * Math.sin(theta) }),
            add: (a, b) => ({ re: a.re + b.re, im: a.im + b.im }),
            sub: (a, b) => ({ re: a.re - b.re, im: a.im - b.im }),
            mul: (a, b) => ({
                re: a.re * b.re - a.im * b.im,
                im: a.re * b.im + a.im * b.re
            }),
            div: (a, b) => {
                const denom = b.re * b.re + b.im * b.im;
                return {
                    re: (a.re * b.re + a.im * b.im) / denom,
                    im: (a.im * b.re - a.re * b.im) / denom
                };
            },
            abs: (c) => Math.sqrt(c.re * c.re + c.im * c.im),
            arg: (c) => Math.atan2(c.im, c.re),
            scale: (c, k) => ({ re: c.re * k, im: c.im * k })
        };

        // Axis parameters storage
        const axisParams = {
            roll: { inertia: 9.16, tau: 20, kp: 0.134, ti: 75.6, td: 42.6, eta: 0.1 },
            pitch: { inertia: 9.16, tau: 20, kp: 0.134, ti: 75.6, td: 42.6, eta: 0.1 },
            yaw: { inertia: 48.0, tau: 20, kp: 0.5, ti: 150, td: 50, eta: 0.1 }
        };

        const axisColors = {
            roll: '#ef4444',   // Red (X)
            pitch: '#22c55e',  // Green (Y)
            yaw: '#3b82f6'     // Blue (Z)
        };

        let currentAxis = 'roll';

        // Transfer function evaluation
        function evalPlant(omega, K, tau_m) {
            const jw = Complex.create(0, omega);
            const jwTau = Complex.create(0, omega * tau_m);
            const term1 = Complex.add(jwTau, Complex.create(1, 0));
            const denom = Complex.mul(jw, term1);
            return Complex.div(Complex.create(K, 0), denom);
        }

        function evalController(omega, Kp, Ti, Td, eta) {
            const jw = Complex.create(0, omega);
            const one = Complex.create(1, 0);
            const integral = Complex.div(one, Complex.scale(jw, Ti));
            const numD = Complex.scale(jw, Td);
            const denomD = Complex.add(Complex.scale(jw, eta * Td), one);
            const derivative = Complex.div(numD, denomD);
            const sum = Complex.add(Complex.add(one, integral), derivative);
            return Complex.scale(sum, Kp);
        }

        function evalOpenLoop(omega, K, tau_m, Kp, Ti, Td, eta) {
            const G = evalPlant(omega, K, tau_m);
            const C = evalController(omega, Kp, Ti, Td, eta);
            return Complex.mul(C, G);
        }

        // Calculate margins
        function calculateMargins(K, tau_m, Kp, Ti, Td, eta) {
            const omegas = [];
            for (let i = -2; i <= 4; i += 0.01) {
                omegas.push(Math.pow(10, i));
            }

            let omega_gc = null, pm = null;
            let omega_pc = null, gm_dB = null;

            for (let i = 1; i < omegas.length; i++) {
                const L_prev = evalOpenLoop(omegas[i-1], K, tau_m, Kp, Ti, Td, eta);
                const L_curr = evalOpenLoop(omegas[i], K, tau_m, Kp, Ti, Td, eta);
                const mag_prev = Complex.abs(L_prev);
                const mag_curr = Complex.abs(L_curr);

                if ((mag_prev >= 1 && mag_curr < 1) || (mag_prev < 1 && mag_curr >= 1)) {
                    const t = (1 - mag_prev) / (mag_curr - mag_prev);
                    omega_gc = omegas[i-1] + t * (omegas[i] - omegas[i-1]);
                    const L_gc = evalOpenLoop(omega_gc, K, tau_m, Kp, Ti, Td, eta);
                    pm = 180 + Complex.arg(L_gc) * 180 / Math.PI;
                    break;
                }
            }

            let prevPhase = null;
            for (let i = 0; i < omegas.length; i++) {
                const L = evalOpenLoop(omegas[i], K, tau_m, Kp, Ti, Td, eta);
                const phase = Complex.arg(L) * 180 / Math.PI;

                if (prevPhase !== null && prevPhase > -180 && phase <= -180) {
                    omega_pc = omegas[i];
                    const L_pc = evalOpenLoop(omega_pc, K, tau_m, Kp, Ti, Td, eta);
                    gm_dB = -20 * Math.log10(Complex.abs(L_pc));
                    break;
                }
                prevPhase = phase;
            }

            return { omega_gc, pm, omega_pc, gm_dB };
        }

        // Calculate peak sensitivity Ms = max|S(jω)| where S = 1/(1+L)
        function calculateSensitivity(K, tau_m, Kp, Ti, Td, eta) {
            const omegas = [];
            for (let i = -2; i <= 4; i += 0.02) {
                omegas.push(Math.pow(10, i));
            }

            let maxS = 0;
            for (const omega of omegas) {
                const L = evalOpenLoop(omega, K, tau_m, Kp, Ti, Td, eta);
                // S = 1/(1+L)
                const one = Complex.create(1, 0);
                const onePlusL = Complex.add(one, L);
                const S = Complex.div(one, onePlusL);
                const magS = Complex.abs(S);
                if (magS > maxS) {
                    maxS = magS;
                }
            }
            return maxS;
        }

        // Optimization objective function
        // Minimizes sensitivity peak while targeting specific PM and bandwidth ratio
        function objectiveFunction(params, K, tau_m, eta, targetPM, targetBWRatio) {
            const [Kp, Ti, Td] = params;

            // Constraints: parameters must be positive
            if (Kp <= 0 || Ti <= 0 || Td <= 0) {
                return 1e10;
            }

            const margins = calculateMargins(K, tau_m, Kp, Ti, Td, eta);
            const Ms = calculateSensitivity(K, tau_m, Kp, Ti, Td, eta);

            // Check stability (must have positive phase margin)
            if (margins.pm === null || margins.pm <= 0) {
                return 1e10;
            }

            const omega_m = 1 / tau_m;
            const bwRatio = margins.omega_gc ? (margins.omega_gc / omega_m * 100) : 0;

            // Objective: minimize Ms with penalties for constraint violations
            let cost = Ms;

            // Soft constraint: phase margin should be close to target
            const pmError = Math.abs(margins.pm - targetPM);
            cost += 0.1 * pmError;

            // Soft constraint: bandwidth ratio should be close to target
            const bwError = Math.abs(bwRatio - targetBWRatio);
            cost += 0.05 * bwError;

            // Penalty for very low phase margin
            if (margins.pm < 30) {
                cost += 10 * (30 - margins.pm);
            }

            // Penalty for very high bandwidth ratio (>50%)
            if (bwRatio > 50) {
                cost += 5 * (bwRatio - 50);
            }

            return cost;
        }

        // Nelder-Mead simplex optimization
        function nelderMead(objective, x0, maxIter = 200, tol = 1e-6) {
            const n = x0.length;
            const alpha = 1.0;  // reflection
            const gamma = 2.0;  // expansion
            const rho = 0.5;    // contraction
            const sigma = 0.5;  // shrink

            // Initialize simplex
            const simplex = [x0.slice()];
            for (let i = 0; i < n; i++) {
                const point = x0.slice();
                point[i] *= 1.2;
                simplex.push(point);
            }

            // Evaluate all vertices
            let values = simplex.map(p => objective(p));

            for (let iter = 0; iter < maxIter; iter++) {
                // Sort vertices by objective value
                const indices = values.map((v, i) => i).sort((a, b) => values[a] - values[b]);
                simplex.sort((a, b) => values[indices.indexOf(simplex.indexOf(a))] - values[indices.indexOf(simplex.indexOf(b))]);
                values.sort((a, b) => a - b);

                // Check convergence
                const range = values[n] - values[0];
                if (range < tol) break;

                // Centroid of all but worst
                const centroid = new Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        centroid[j] += simplex[i][j] / n;
                    }
                }

                // Reflection
                const xr = centroid.map((c, j) => c + alpha * (c - simplex[n][j]));
                const fr = objective(xr);

                if (fr >= values[0] && fr < values[n - 1]) {
                    simplex[n] = xr;
                    values[n] = fr;
                } else if (fr < values[0]) {
                    // Expansion
                    const xe = centroid.map((c, j) => c + gamma * (xr[j] - c));
                    const fe = objective(xe);
                    if (fe < fr) {
                        simplex[n] = xe;
                        values[n] = fe;
                    } else {
                        simplex[n] = xr;
                        values[n] = fr;
                    }
                } else {
                    // Contraction
                    const xc = centroid.map((c, j) => c + rho * (simplex[n][j] - c));
                    const fc = objective(xc);
                    if (fc < values[n]) {
                        simplex[n] = xc;
                        values[n] = fc;
                    } else {
                        // Shrink
                        for (let i = 1; i <= n; i++) {
                            for (let j = 0; j < n; j++) {
                                simplex[i][j] = simplex[0][j] + sigma * (simplex[i][j] - simplex[0][j]);
                            }
                            values[i] = objective(simplex[i]);
                        }
                    }
                }
            }

            // Return best point
            const bestIdx = values.indexOf(Math.min(...values));
            return simplex[bestIdx];
        }

        // Run optimization
        function runOptimization() {
            const btn = document.getElementById('optimize-btn');
            btn.disabled = true;
            btn.textContent = '最適化中... / Optimizing...';

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                const I = parseFloat(document.getElementById('inertia-input').value) * 1e-6;
                const tau_m = parseFloat(document.getElementById('tau-input').value) / 1000;
                const eta = parseFloat(document.getElementById('eta-input').value);
                const targetPM = parseFloat(document.getElementById('target-pm').value);
                const targetBWRatio = parseFloat(document.getElementById('target-bw-ratio').value);

                const K = 1 / I;

                // Initial guess from current values
                const Kp0 = parseFloat(document.getElementById('kp-input').value) * 1e-3;
                const Ti0 = parseFloat(document.getElementById('ti-input').value) / 1000;
                const Td0 = parseFloat(document.getElementById('td-input').value) / 1000;

                const objective = (params) => objectiveFunction(params, K, tau_m, eta, targetPM, targetBWRatio);

                // Run optimization
                const result = nelderMead(objective, [Kp0, Ti0, Td0], 300);

                const [KpOpt, TiOpt, TdOpt] = result;

                // Update UI with optimized values
                document.getElementById('kp-input').value = (KpOpt * 1e3).toFixed(3);
                document.getElementById('kp-slider').value = (KpOpt * 1e3).toFixed(3);
                document.getElementById('ti-input').value = (TiOpt * 1000).toFixed(1);
                document.getElementById('ti-slider').value = (TiOpt * 1000).toFixed(1);
                document.getElementById('td-input').value = (TdOpt * 1000).toFixed(1);
                document.getElementById('td-slider').value = (TdOpt * 1000).toFixed(1);

                btn.disabled = false;
                btn.textContent = '感度関数を最小化 / Minimize Sensitivity';

                updatePlots();
            }, 50);
        }

        // Closed-loop step response (numerical simulation)
        function simulateStepResponse(K, tau_m, Kp, Ti, Td, eta, tMax, dt) {
            const t = [];
            const y = [];

            let omega_state = 0;
            let motor_state = 0;
            let integral = 0;
            let deriv_state = 0;
            let prev_error = 0;

            const target = 1;

            for (let time = 0; time <= tMax; time += dt) {
                t.push(time);
                y.push(omega_state);

                const error = target - omega_state;

                integral += error * dt / Ti;
                const deriv_raw = (error - prev_error) / dt;
                deriv_state += (deriv_raw * Td - deriv_state) * dt / (eta * Td);

                const u = Kp * (error + integral + deriv_state);

                const d_motor = (u - motor_state) / tau_m;
                motor_state += d_motor * dt;

                omega_state += motor_state * K * dt;

                prev_error = error;
            }

            return { t, y };
        }

        // Get axis parameters from storage
        function getAxisParams(axis) {
            const p = axisParams[axis];
            const I = p.inertia * 1e-6;
            const tau_m = p.tau / 1000;
            const Kp = p.kp * 1e-3;
            const Ti = p.ti / 1000;
            const Td = p.td / 1000;
            const eta = p.eta;
            const K = 1 / I;
            return { I, tau_m, Kp, Ti, Td, eta, K };
        }

        // Calculate frequency response for an axis
        function calcFreqResponse(axis, omegas) {
            const { K, tau_m, Kp, Ti, Td, eta } = getAxisParams(axis);

            const mag_L = [], phase_L = [];
            let unwrapOffset = 0;
            let prevPhase_L = null;

            for (const omega of omegas) {
                const L = evalOpenLoop(omega, K, tau_m, Kp, Ti, Td, eta);
                mag_L.push(20 * Math.log10(Complex.abs(L)));

                let ph_L = Complex.arg(L) * 180 / Math.PI;
                if (prevPhase_L !== null && ph_L - prevPhase_L > 180) {
                    unwrapOffset -= 360;
                } else if (prevPhase_L !== null && ph_L - prevPhase_L < -180) {
                    unwrapOffset += 360;
                }
                prevPhase_L = ph_L;
                phase_L.push(ph_L + unwrapOffset);
            }

            const margins = calculateMargins(K, tau_m, Kp, Ti, Td, eta);
            return { mag_L, phase_L, margins };
        }

        // Save current UI values to axis storage
        function saveCurrentParams() {
            if (currentAxis === 'all') return;
            axisParams[currentAxis] = {
                inertia: parseFloat(document.getElementById('inertia-input').value),
                tau: parseFloat(document.getElementById('tau-input').value),
                kp: parseFloat(document.getElementById('kp-input').value),
                ti: parseFloat(document.getElementById('ti-input').value),
                td: parseFloat(document.getElementById('td-input').value),
                eta: parseFloat(document.getElementById('eta-input').value)
            };
        }

        // Load axis values to UI
        function loadAxisParams(axis) {
            const p = axisParams[axis];
            document.getElementById('inertia-input').value = p.inertia;
            document.getElementById('inertia-slider').value = p.inertia;
            document.getElementById('tau-input').value = p.tau;
            document.getElementById('tau-slider').value = p.tau;
            document.getElementById('kp-input').value = p.kp;
            document.getElementById('kp-slider').value = p.kp;
            document.getElementById('ti-input').value = p.ti;
            document.getElementById('ti-slider').value = p.ti;
            document.getElementById('td-input').value = p.td;
            document.getElementById('td-slider').value = p.td;
            document.getElementById('eta-input').value = p.eta;
            document.getElementById('eta-slider').value = p.eta;
        }

        // Update single axis plot
        function updateSingleAxisPlot() {
            saveCurrentParams();

            const { I, tau_m, Kp, Ti, Td, eta, K } = getAxisParams(currentAxis);
            const omega_m = 1 / tau_m;

            const omegas = [];
            for (let i = -1; i <= 4; i += 0.02) {
                omegas.push(Math.pow(10, i));
            }

            const mag_L = [], phase_L = [];
            const mag_G = [], phase_G = [];
            const mag_C = [], phase_C = [];

            let unwrapOffset = 0;
            let prevPhase_L = null;

            for (const omega of omegas) {
                const L = evalOpenLoop(omega, K, tau_m, Kp, Ti, Td, eta);
                const G = evalPlant(omega, K, tau_m);
                const C = evalController(omega, Kp, Ti, Td, eta);

                mag_L.push(20 * Math.log10(Complex.abs(L)));
                mag_G.push(20 * Math.log10(Complex.abs(G)));
                mag_C.push(20 * Math.log10(Complex.abs(C)));

                let ph_L = Complex.arg(L) * 180 / Math.PI;
                if (prevPhase_L !== null && ph_L - prevPhase_L > 180) {
                    unwrapOffset -= 360;
                } else if (prevPhase_L !== null && ph_L - prevPhase_L < -180) {
                    unwrapOffset += 360;
                }
                prevPhase_L = ph_L;
                phase_L.push(ph_L + unwrapOffset);

                phase_G.push(Complex.arg(G) * 180 / Math.PI);
                phase_C.push(Complex.arg(C) * 180 / Math.PI);
            }

            const margins = calculateMargins(K, tau_m, Kp, Ti, Td, eta);

            // Update results display
            const wgcEl = document.getElementById('result-wgc');
            const pmEl = document.getElementById('result-pm');
            const gmEl = document.getElementById('result-gm');

            if (margins.omega_gc) {
                wgcEl.textContent = margins.omega_gc.toFixed(1) + ' rad/s';
                wgcEl.className = 'result-value';
            } else {
                wgcEl.textContent = 'N/A';
                wgcEl.className = 'result-value warning';
            }

            if (margins.pm !== null) {
                pmEl.textContent = margins.pm.toFixed(1) + '°';
                pmEl.className = 'result-value' + (margins.pm < 30 ? ' danger' : margins.pm < 45 ? ' warning' : '');
            } else {
                pmEl.textContent = 'N/A';
                pmEl.className = 'result-value warning';
            }

            if (margins.gm_dB !== null) {
                gmEl.textContent = margins.gm_dB.toFixed(1) + ' dB';
                gmEl.className = 'result-value' + (margins.gm_dB < 6 ? ' warning' : '');
            } else {
                gmEl.textContent = '∞ dB';
                gmEl.className = 'result-value';
            }

            document.getElementById('result-wm').textContent = omega_m.toFixed(1) + ' rad/s';

            if (margins.omega_gc) {
                const ratio = (margins.omega_gc / omega_m * 100);
                const ratioEl = document.getElementById('result-ratio');
                ratioEl.textContent = ratio.toFixed(1) + '%';
                ratioEl.className = 'result-value' + (ratio > 50 ? ' warning' : '');
            }

            // Calculate and display sensitivity peak
            const Ms = calculateSensitivity(K, tau_m, Kp, Ti, Td, eta);
            const Ms_dB = 20 * Math.log10(Ms);
            const msEl = document.getElementById('result-ms');
            msEl.textContent = Ms_dB.toFixed(1) + ' dB';
            // Ms > 6dB (2.0) is concerning, Ms > 9dB (2.8) is dangerous
            msEl.className = 'sensitivity-value' + (Ms_dB > 9 ? ' danger' : Ms_dB > 6 ? ' warning' : '');

            document.getElementById('tf-plant').textContent =
                `G(s) = ${(K/1000).toFixed(2)}×10³ / (s(${(tau_m*1000).toFixed(1)}ms·s + 1))`;

            // Bode plot
            const plotLayout = {
                paper_bgcolor: '#16213e',
                plot_bgcolor: '#0f0f23',
                font: { color: '#eee', size: 11 },
                margin: { t: 40, r: 30, b: 40, l: 60 },
                grid: { rows: 2, columns: 1, pattern: 'independent' },
                xaxis: { type: 'log', title: '', gridcolor: '#333', showline: true, linecolor: '#444' },
                xaxis2: { type: 'log', title: 'Frequency [rad/s]', gridcolor: '#333', showline: true, linecolor: '#444' },
                yaxis: { title: 'Magnitude [dB]', gridcolor: '#333', range: [-80, 120], showline: true, linecolor: '#444', domain: [0.55, 1] },
                yaxis2: { title: 'Phase [deg]', gridcolor: '#333', range: [-270, 90], showline: true, linecolor: '#444', domain: [0, 0.45] },
                showlegend: false,
                shapes: [
                    { type: 'line', x0: 0.1, x1: 10000, y0: 0, y1: 0, xref: 'x', yref: 'y', line: { color: '#666', width: 1, dash: 'dot' } },
                    { type: 'line', x0: 0.1, x1: 10000, y0: -180, y1: -180, xref: 'x2', yref: 'y2', line: { color: '#666', width: 1, dash: 'dot' } }
                ]
            };

            if (margins.omega_gc) {
                plotLayout.shapes.push({
                    type: 'line', x0: margins.omega_gc, x1: margins.omega_gc, y0: -80, y1: 120,
                    xref: 'x', yref: 'y', line: { color: '#3b82f6', width: 1, dash: 'dash' }
                });
                plotLayout.shapes.push({
                    type: 'line', x0: margins.omega_gc, x1: margins.omega_gc, y0: -270, y1: 90,
                    xref: 'x2', yref: 'y2', line: { color: '#3b82f6', width: 1, dash: 'dash' }
                });
            }

            const bodeData = [
                { x: omegas, y: mag_L, type: 'scatter', mode: 'lines', line: { color: '#3b82f6', width: 2.5 }, xaxis: 'x', yaxis: 'y' },
                { x: omegas, y: mag_G, type: 'scatter', mode: 'lines', line: { color: '#22c55e', width: 1.5, dash: 'dash' }, xaxis: 'x', yaxis: 'y' },
                { x: omegas, y: mag_C, type: 'scatter', mode: 'lines', line: { color: '#ef4444', width: 1.5, dash: 'dashdot' }, xaxis: 'x', yaxis: 'y' },
                { x: omegas, y: phase_L, type: 'scatter', mode: 'lines', line: { color: '#3b82f6', width: 2.5 }, xaxis: 'x2', yaxis: 'y2' },
                { x: omegas, y: phase_G, type: 'scatter', mode: 'lines', line: { color: '#22c55e', width: 1.5, dash: 'dash' }, xaxis: 'x2', yaxis: 'y2' },
                { x: omegas, y: phase_C, type: 'scatter', mode: 'lines', line: { color: '#ef4444', width: 1.5, dash: 'dashdot' }, xaxis: 'x2', yaxis: 'y2' }
            ];

            // Add overlay axes (other axes that are checked)
            const overlayAxes = ['roll', 'pitch', 'yaw'].filter(axis =>
                axis !== currentAxis && document.getElementById(`overlay-${axis}`).checked
            );

            for (const axis of overlayAxes) {
                const { mag_L: oMag, phase_L: oPhase } = calcFreqResponse(axis, omegas);
                const color = axisColors[axis];
                bodeData.push({
                    x: omegas, y: oMag, type: 'scatter', mode: 'lines',
                    line: { color, width: 1.5, dash: 'dot' }, xaxis: 'x', yaxis: 'y'
                });
                bodeData.push({
                    x: omegas, y: oPhase, type: 'scatter', mode: 'lines',
                    line: { color, width: 1.5, dash: 'dot' }, xaxis: 'x2', yaxis: 'y2'
                });
            }

            Plotly.react('bode-plot', bodeData, plotLayout, { responsive: true });

            // Step response
            const tMax = parseFloat(document.getElementById('time-range-input').value);
            const stepData = simulateStepResponse(K, tau_m, Kp, Ti, Td, eta, tMax, 0.001);

            const stepLayout = {
                paper_bgcolor: '#16213e',
                plot_bgcolor: '#0f0f23',
                font: { color: '#eee', size: 11 },
                margin: { t: 40, r: 30, b: 50, l: 60 },
                title: { text: 'Closed-Loop Step Response', font: { size: 14 } },
                xaxis: { title: 'Time [s]', gridcolor: '#333', showline: true, linecolor: '#444', range: [0, tMax] },
                yaxis: { title: 'Response', gridcolor: '#333', showline: true, linecolor: '#444', range: [0, 1.5] },
                shapes: [
                    { type: 'line', x0: 0, x1: tMax, y0: 1, y1: 1, line: { color: '#666', width: 1, dash: 'dash' } },
                    { type: 'line', x0: 0, x1: tMax, y0: 1.05, y1: 1.05, line: { color: '#ef4444', width: 1, dash: 'dot' } },
                    { type: 'line', x0: 0, x1: tMax, y0: 0.95, y1: 0.95, line: { color: '#ef4444', width: 1, dash: 'dot' } }
                ],
                showlegend: false
            };

            const stepPlotData = [
                { x: stepData.t, y: stepData.y, type: 'scatter', mode: 'lines', line: { color: '#3b82f6', width: 2 } }
            ];

            // Add overlay step responses
            for (const axis of overlayAxes) {
                const params = getAxisParams(axis);
                const oStepData = simulateStepResponse(params.K, params.tau_m, params.Kp, params.Ti, params.Td, params.eta, tMax, 0.001);
                stepPlotData.push({
                    x: oStepData.t, y: oStepData.y, type: 'scatter', mode: 'lines',
                    line: { color: axisColors[axis], width: 1.5, dash: 'dot' }
                });
            }

            Plotly.react('step-plot', stepPlotData, stepLayout, { responsive: true });
        }

        // Update all axes overlay plot
        function updateAllAxesPlot() {
            const omegas = [];
            for (let i = -1; i <= 4; i += 0.02) {
                omegas.push(Math.pow(10, i));
            }

            const axes = ['roll', 'pitch', 'yaw'];
            const bodeData = [];

            for (const axis of axes) {
                const { mag_L, phase_L, margins } = calcFreqResponse(axis, omegas);
                const color = axisColors[axis];

                bodeData.push({
                    x: omegas, y: mag_L, type: 'scatter', mode: 'lines',
                    line: { color, width: 2 }, name: axis, xaxis: 'x', yaxis: 'y'
                });
                bodeData.push({
                    x: omegas, y: phase_L, type: 'scatter', mode: 'lines',
                    line: { color, width: 2 }, name: axis, xaxis: 'x2', yaxis: 'y2'
                });

                // Update table
                const p = axisParams[axis];
                document.getElementById(`all-inertia-${axis}`).textContent = p.inertia.toFixed(2);
                document.getElementById(`all-kp-${axis}`).textContent = p.kp.toFixed(3);
                document.getElementById(`all-ti-${axis}`).textContent = p.ti.toFixed(1);
                document.getElementById(`all-td-${axis}`).textContent = p.td.toFixed(1);
                document.getElementById(`all-wgc-${axis}`).textContent = margins.omega_gc ? margins.omega_gc.toFixed(1) : 'N/A';
                document.getElementById(`all-pm-${axis}`).textContent = margins.pm !== null ? margins.pm.toFixed(1) : 'N/A';
                document.getElementById(`all-gm-${axis}`).textContent = margins.gm_dB !== null ? margins.gm_dB.toFixed(1) : '∞';
            }

            const plotLayout = {
                paper_bgcolor: '#16213e',
                plot_bgcolor: '#0f0f23',
                font: { color: '#eee', size: 11 },
                margin: { t: 40, r: 30, b: 40, l: 60 },
                grid: { rows: 2, columns: 1, pattern: 'independent' },
                xaxis: { type: 'log', title: '', gridcolor: '#333', showline: true, linecolor: '#444' },
                xaxis2: { type: 'log', title: 'Frequency [rad/s]', gridcolor: '#333', showline: true, linecolor: '#444' },
                yaxis: { title: 'Magnitude [dB]', gridcolor: '#333', range: [-80, 120], showline: true, linecolor: '#444', domain: [0.55, 1] },
                yaxis2: { title: 'Phase [deg]', gridcolor: '#333', range: [-270, 90], showline: true, linecolor: '#444', domain: [0, 0.45] },
                showlegend: false,
                shapes: [
                    { type: 'line', x0: 0.1, x1: 10000, y0: 0, y1: 0, xref: 'x', yref: 'y', line: { color: '#666', width: 1, dash: 'dot' } },
                    { type: 'line', x0: 0.1, x1: 10000, y0: -180, y1: -180, xref: 'x2', yref: 'y2', line: { color: '#666', width: 1, dash: 'dot' } }
                ]
            };

            Plotly.react('bode-plot', bodeData, plotLayout, { responsive: true });

            // Step response for all axes
            const tMax = parseFloat(document.getElementById('time-range-input').value);
            const stepPlotData = [];

            for (const axis of axes) {
                const { K, tau_m, Kp, Ti, Td, eta } = getAxisParams(axis);
                const stepData = simulateStepResponse(K, tau_m, Kp, Ti, Td, eta, tMax, 0.001);
                stepPlotData.push({
                    x: stepData.t, y: stepData.y, type: 'scatter', mode: 'lines',
                    line: { color: axisColors[axis], width: 2 }, name: axis
                });
            }

            const stepLayout = {
                paper_bgcolor: '#16213e',
                plot_bgcolor: '#0f0f23',
                font: { color: '#eee', size: 11 },
                margin: { t: 40, r: 30, b: 50, l: 60 },
                title: { text: 'Closed-Loop Step Response (All Axes)', font: { size: 14 } },
                xaxis: { title: 'Time [s]', gridcolor: '#333', showline: true, linecolor: '#444', range: [0, tMax] },
                yaxis: { title: 'Response', gridcolor: '#333', showline: true, linecolor: '#444', range: [0, 1.5] },
                shapes: [
                    { type: 'line', x0: 0, x1: tMax, y0: 1, y1: 1, line: { color: '#666', width: 1, dash: 'dash' } },
                    { type: 'line', x0: 0, x1: tMax, y0: 1.05, y1: 1.05, line: { color: '#888', width: 1, dash: 'dot' } },
                    { type: 'line', x0: 0, x1: tMax, y0: 0.95, y1: 0.95, line: { color: '#888', width: 1, dash: 'dot' } }
                ],
                showlegend: false
            };

            Plotly.react('step-plot', stepPlotData, stepLayout, { responsive: true });
        }

        // Main update function
        function updatePlots() {
            if (currentAxis === 'all') {
                updateAllAxesPlot();
            } else {
                updateSingleAxisPlot();
            }
        }

        // Update overlay checkboxes state
        function updateOverlayCheckboxes() {
            const axes = ['roll', 'pitch', 'yaw'];
            for (const axis of axes) {
                const container = document.getElementById(`overlay-${axis}-container`);
                const checkbox = document.getElementById(`overlay-${axis}`);
                if (axis === currentAxis) {
                    container.classList.add('disabled');
                    checkbox.disabled = true;
                    checkbox.checked = false;
                } else {
                    container.classList.remove('disabled');
                    checkbox.disabled = false;
                }
            }
        }

        // Switch axis
        function switchAxis(axis) {
            // Save current params before switching
            saveCurrentParams();

            currentAxis = axis;

            // Update tab UI
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.tab[data-axis="${axis}"]`).classList.add('active');

            // Update axis indicator
            const axisLabel = document.getElementById('axis-label');
            if (axis !== 'all') {
                axisLabel.textContent = axis.charAt(0).toUpperCase() + axis.slice(1);
                axisLabel.className = `axis-indicator ${axis}`;
            }

            // Toggle panel visibility
            const singleParams = document.querySelector('.single-view-params');
            const allParams = document.querySelector('.all-view-params');
            const singleLegend = document.getElementById('single-legend');

            if (axis === 'all') {
                singleParams.classList.add('hidden');
                allParams.classList.add('visible');
                singleLegend.style.display = 'none';
            } else {
                singleParams.classList.remove('hidden');
                allParams.classList.remove('visible');
                singleLegend.style.display = 'flex';
                loadAxisParams(axis);
                updateOverlayCheckboxes();
            }

            updatePlots();
        }

        // Sync slider and input
        function syncInputs(sliderId, inputId) {
            const slider = document.getElementById(sliderId);
            const input = document.getElementById(inputId);

            slider.addEventListener('input', () => {
                input.value = slider.value;
                updatePlots();
            });

            input.addEventListener('input', () => {
                slider.value = input.value;
                updatePlots();
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            syncInputs('inertia-slider', 'inertia-input');
            syncInputs('tau-slider', 'tau-input');
            syncInputs('kp-slider', 'kp-input');
            syncInputs('ti-slider', 'ti-input');
            syncInputs('td-slider', 'td-input');
            syncInputs('eta-slider', 'eta-input');
            syncInputs('time-range-slider', 'time-range-input');

            // Overlay checkbox handlers
            ['roll', 'pitch', 'yaw'].forEach(axis => {
                document.getElementById(`overlay-${axis}`).addEventListener('change', updatePlots);
            });

            // Initialize overlay checkboxes state
            updateOverlayCheckboxes();

            // Tab click handlers
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    switchAxis(tab.dataset.axis);
                });
            });

            // Optimize button handler
            document.getElementById('optimize-btn').addEventListener('click', runOptimization);

            updatePlots();
        });
    </script>
</body>
</html>
